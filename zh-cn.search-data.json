{"/docs/":{"data":{"":"","简介#简介":"涉及的所有部署和配置环境，如果无特殊说明，均在centos7.9 和 rocky9上完成。\nlinux k8s docker 脚本工具 运维服务 网络安全 数据库"},"title":"文档"},"/docs/%E5%AE%B9%E5%99%A8/":{"data":{"简介#简介":"简介docker docker-compose 容器化 镜像 容器 部署 安装 命令 运维\n本目录包含 Docker 安装教程、Docker 常用命令详解、Docker Compose 容器编排、Docker 镜像管理、容器运维等全套核心文档。"},"title":"容器"},"/docs/%E5%AE%B9%E5%99%A8/docker%E5%9F%BA%E7%A1%80/":{"data":{"":"","1-centos-7-安装步骤#1. CentOS 7 安装步骤":"# 1. 卸载旧版本（若有） yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine # 2. 安装依赖包 yum install -y yum-utils device-mapper-persistent-data lvm2 # 3. 设置 Docker 官方仓库（国内推荐阿里云镜像加速） yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 4. 安装 Docker CE（社区版，免费） yum install -y docker-ce docker-ce-cli containerd.io # 5. 启动 Docker 并设置开机自启 systemctl start docker systemctl enable docker # 6. 验证安装成功（显示版本即正常） docker --version","2-配置国内镜像加速解决拉取镜像慢的问题#2. 配置国内镜像加速（解决拉取镜像慢的问题）":"默认从 Docker Hub 拉取镜像较慢，配置阿里云 / 网易云加速：\n# 1. 创建配置目录 mkdir -p /etc/docker # 2. 编写配置文件（以下加速地址暂时可用） cat \u003e /etc/docker/daemon.json \u003c","一docker-核心概念先搞懂再动手#一、Docker 核心概念（先搞懂再动手）":"在开始操作前，先明确 3 个核心概念，避免 confusion：\n镜像（Image）：Docker 应用的 “安装包”，包含运行应用所需的代码、依赖、环境配置（如 CentOS 镜像、Nginx 镜像）。\n容器（Container）：镜像的 “运行实例”，是独立的可执行环境（类似轻量级虚拟机，但更高效），多个容器可共享同一个镜像。\n仓库（Repository）：存放镜像的 “仓库”（类似 GitHub），官方仓库是 Docker Hub，包含海量开源镜像。","三docker-核心命令#三、Docker 核心命令":"命令 功能 示例 docker pull 镜像名:标签 拉取镜像（标签默认 latest，即最新版） docker pull nginx:1.24（拉取 Nginx 1.24 版本） docker images 查看本地所有镜像 docker images（显示镜像名、标签、ID、大小） docker rmi 镜像ID/镜像名 删除镜像（需先停止依赖该镜像的容器） docker rmi nginx:1.24 或 docker rmi 0e901e68141f docker search 镜像名 搜索 Docker Hub 上的镜像 docker search mysql（搜索 MySQL 镜像） docker save -o 文件名.tar 镜像名 导出镜像到本地文件 docker save -o nginx.tar nginx:1.24 docker load -i 文件名.tar 从本地文件导入镜像 docker load -i nginx.tar docker ps 查看运行中的容器 docker ps（-a 查看所有容器，包括停止的） docker start 容器名/容器ID 启动已停止的容器 docker start mynginx docker stop 容器名/容器ID 停止运行中的容器 docker stop mynginx（kill 强制停止：docker kill mynginx） docker restart 容器名/容器ID 重启容器 docker restart mynginx docker exec -it 容器名/容器ID 命令 进入运行中的容器（交互式） docker exec -it mynginx /bin/bash（进入 Nginx 容器终端） docker logs 容器名/容器ID 查看容器日志 docker logs -f mynginx（-f 实时跟踪日志） docker rm 容器名/容器ID 删除容器（需先停止容器） docker rm mynginx（强制删除运行中的容器：docker rm -f mynginx） docker inspect 容器名/容器ID 查看容器详细信息（IP、挂载等） docker inspect mynginx","二docker-安装#二、Docker 安装":"","四清理磁盘空间#四、清理磁盘空间":"# 清理停止的容器 docker container prune # 清理无用镜像（无标签、未被容器使用） docker image prune -a # 清理无用数据卷 docker volume prune # 一键清理所有无用资源（容器、镜像、网络、数据卷） docker system prune -af"},"title":"Docker基础"},"/docs/%E5%AE%B9%E5%99%A8/docker%E5%AD%98%E5%82%A8/":{"data":{"":"","docker数据持久化方案#Docker数据持久化方案":"Docker提供3种核心数据持久化方式，按推荐优先级排序：卷（Volume）\u003e 绑定挂载（Bind Mount）\u003e tmpfs挂载。不同方案的适用场景不同，需根据业务需求选择。","tmpfs挂载#tmpfs挂载":"tmpfs挂载是将容器数据存储在宿主机的内存中，不写入磁盘，容器停止、重启后，数据会立即丢失。其核心优势是读写速度极快，适用于存储临时数据（如缓存、临时计算结果、会话数据），不适合需要持久化的数据。\ntmpfs挂载的常用操作\n# 1. 命令行tmpfs挂载（仅指定容器内路径，自动分配内存） docker run -it --name test-container --tmpfs /app/tmp nginx # 2. 限制tmpfs挂载的内存大小（如限制为100MB） docker run -it --name test-container --tmpfs /app/tmp:size=100m nginx","三种持久化方案对比#三种持久化方案对比":"对比维度 卷（Volume） 绑定挂载（Bind Mount） tmpfs挂载 数据持久化 支持（容器销毁后数据保留） 支持（依赖宿主机目录） 不支持（容器停止后数据丢失） 与宿主机耦合度 低（Docker管理，解耦） 高（依赖宿主机目录结构） 中（依赖宿主机内存） 权限管理 Docker自动处理，安全便捷 手动配置，易出现权限问题 无需配置，仅容器内可用 读写性能 高（接近磁盘性能） 高（直接操作宿主机磁盘） 极高（内存读写） 可移植性 高（支持跨宿主机迁移） 低（需同步宿主机目录） 无（数据不持久） 管理便捷性 高（Docker命令统一管理） 低（手动操作宿主机目录） 中（仅需配置挂载路径） 适用场景 生产/测试/开发，需持久化、共享数据 开发调试，需复用宿主机目录 临时数据、缓存、敏感临时数据","卷volume#卷（Volume）":"按创建方式，卷分为3类，适配不同场景：\n命名卷（Named Volume）：用户手动创建，指定卷名称，可重复使用、跨容器共享，管理便捷（推荐用于生产环境）；\n匿名卷（Anonymous Volume）：用户不指定卷名称，Docker自动生成随机名称，容器销毁后，若未手动删除，卷会保留（适合临时持久化、无需共享的场景）；\n外部卷（External Volume）：引用已存在的卷（如其他项目创建的卷、NFS共享卷、云存储卷），实现数据跨项目、跨环境共享。\n创建卷\n# 1. 创建命名卷（最常用） docker volume create my-volume # 2. 创建自定义参数的卷（如NFS卷、指定存储路径） # 示例：创建NFS类型的命名卷，挂载远程NFS共享目录 docker volume create --driver local \\ --opt type=nfs \\ --opt o=addr=192.168.1.100,rw,noatime \\ --opt device=:/nfs-share/docker-volumes \\ my-nfs-volume # 3. 匿名卷（无需手动创建，启动容器时自动生成） # 启动容器时，指定-v /容器路径，即可自动创建匿名卷 docker run -it -v /app/data nginx 容器挂载卷 支持两种挂载方式：命令行挂载、Docker Compose挂载，后者更适合多服务场景。\n# 方式1：命令行挂载（启动容器时挂载） # 挂载命名卷（my-volume → 容器内/app/data） docker run -it --name test-container -v my-volume:/app/data nginx # 挂载匿名卷（自动生成 → 容器内/app/logs） docker run -it --name test-container -v /app/logs nginx # 挂载外部卷（引用已存在的卷，需确保卷已创建） docker run -it --name test-container -v my-nfs-volume:/app/nfs nginx # 只读挂载（仅允许容器读取卷数据，禁止修改） docker run -it --name test-container -v my-volume:/app/data:ro nginx","概述#概述":"本文档详细介绍Docker存储的核心原理、存储驱动、数据持久化方案、卷（Volume）管理、实操命令及常见问题排查，帮助开发/运维人员全面掌握Docker容器数据的存储、管理、备份与迁移技巧，解决容器数据临时存储、持久化、共享等核心需求，保障容器数据的安全性、持久性和可维护性。\n核心概念\n理解Docker存储的核心概念，是掌握各类存储方案的基础，关键概念定义及说明如下：\n概念 定义 补充说明 联合文件系统（UnionFS） Docker基础存储架构，将多个只读层（镜像层）和一个可写层（容器层）叠加，形成统一的文件系统视图 核心优势：节省磁盘空间，多个容器可共享镜像只读层；写操作仅作用于可写层，不修改镜像本身 存储驱动（Storage Driver） 实现UnionFS叠加逻辑的核心组件，负责管理镜像层和容器可写层的创建、删除、挂载 不同驱动适配不同Linux内核和文件系统，直接影响存储性能、磁盘占用和兼容性 卷（Volume） Docker官方推荐的持久化方式，由Docker统一管理的宿主机目录，与容器生命周期解耦 默认存储路径：/var/lib/docker/volumes/，支持跨容器共享、备份，权限由Docker自动管理 绑定挂载（Bind Mount） 将宿主机任意目录/文件直接挂载到容器内指定路径，实现容器与宿主机的数据互通 灵活性高，但依赖宿主机目录结构，权限配置复杂，与宿主机耦合度高 tmpfs挂载 将容器数据存储在宿主机内存中，不写入磁盘，容器停止后数据立即丢失 适用于临时数据存储（如缓存、临时计算结果），读写速度极快，但受内存大小限制 可写层（Writable Layer） 容器启动时，在镜像只读层之上创建的临时可写层，容器所有写操作（创建、修改、删除文件）均作用于该层 生命周期与容器一致，容器销毁则可写层删除；性能低于卷和绑定挂载，不适合持久化存储 镜像层（Image Layer） Docker镜像由多个只读层叠加组成，每个层对应镜像构建过程中的一条指令（如FROM、COPY） 多个容器可共享同一镜像的只读层，节省磁盘空间；镜像层不可修改，修改需通过创建新层实现","绑定挂载bind-mount#绑定挂载（Bind Mount）":"绑定挂载是将宿主机的任意目录/文件，直接挂载到容器内指定路径，容器内对该路径的读写操作，会直接同步到宿主机对应目录/文件。其核心优势是灵活性高，可直接复用宿主机已有目录，但与宿主机耦合度高，不推荐生产环境优先使用。\n绑定挂载的常用操作\n# 1. 命令行绑定挂载（宿主机目录 → 容器目录） # 示例：将宿主机/root/app/data 挂载到容器/app/data docker run -it --name test-container -v /root/app/data:/app/data nginx # 2. 绑定挂载文件（宿主机文件 → 容器文件，需确保宿主机文件存在） # 示例：将宿主机/root/app/nginx.conf 挂载到容器/etc/nginx/nginx.conf docker run -it --name test-container -v /root/app/nginx.conf:/etc/nginx/nginx.conf nginx # 3. 只读绑定挂载（容器仅可读取，不可修改宿主机文件/目录） docker run -it --name test-container -v /root/app/data:/app/data:ro nginx # 4. 宽松权限挂载（解决容器内权限不足问题，适用于CentOS等系统） docker run -it --name test-container -v /root/app/data:/app/data:Z nginx"},"title":"Docker存储"},"/docs/%E5%AE%B9%E5%99%A8/docker%E7%BD%91%E7%BB%9C/":{"data":{"":"","bridge模式默认模式#bridge模式（默认模式）":"原理\nbridge模式是Docker容器默认使用的网络模式，宿主机会创建一个名为docker0的虚拟网桥，所有使用bridge模式的容器都会连接到该网桥上，容器通过网桥实现与其他容器、宿主机及外部网络的通信。\n容器启动时，Docker会为容器分配一个独立的虚拟网卡（veth pair），一端连接容器的网络命名空间，另一端连接docker0网桥，同时为容器分配一个来自私有网段（默认172.17.0.0/16）的IP地址，网关指向docker0网桥的IP（默认172.17.0.1）。\n特点\n容器拥有独立的网络命名空间，网络环境隔离；\n同一宿主机上的容器可通过docker0网桥直接通信，无需端口映射；\n容器访问外部网络需通过宿主机的NAT转换（宿主机将容器IP转换为自身公网/内网IP）；\n外部网络访问容器需配置端口映射。\n使用方式\n默认情况下，容器启动时自动使用bridge模式，无需额外配置：\n# 启动容器，默认使用bridge模式 docker run -it --name test-container nginx 手动指定bridge模式（与默认效果一致）：\ndocker run -it --name test-container --network bridge nginx","docker自定义网络#Docker自定义网络":"# 基本创建（默认自动分配网段） docker network create my-bridge-network # 自定义网段、网关创建（推荐） docker network create --driver bridge --subnet 172.20.0.0/16 --gateway 172.20.0.1 my-bridge-network 参数说明：\n--driver bridge：指定网络驱动为bridge；\n--subnet：指定自定义网段（如172.20.0.0/16）；\n--gateway：指定网关IP（需在subnet网段内）；\nmy-bridge-network：自定义网络名称。\n容器加入自定义网络\n# 方式1：启动容器时加入 docker run -it --name test-container1 --network my-bridge-network nginx # 方式2：为运行中的容器加入（需重启容器生效） docker network connect my-bridge-network test-container2 为容器分配固定IP\n# 启动容器时指定固定IP（IP需在自定义网络的subnet网段内） docker run -it --name test-fixed-ip --network my-bridge-network --ip 172.20.0.10 nginx","host模式#host模式":"原理\nhost模式下，容器不会创建独立的网络命名空间，而是直接共享宿主机的网络命名空间，容器的网卡、IP地址、路由表、端口等网络资源与宿主机完全一致。\n容器启动后，其内部监听的端口会直接占用宿主机的对应端口，外部网络可通过宿主机IP+端口直接访问容器服务，无需配置端口映射。\n特点\n容器不占用额外的IP地址，共享宿主机网络资源；\n网络性能最优，无NAT转换和网桥转发的开销；\n端口冲突风险高（容器与宿主机、其他host模式容器的端口不能重复）；\n网络环境无隔离，容器可直接访问宿主机的所有网络资源。\n使用方式\n通过--network host参数指定host模式：\n# 启动容器，使用host模式，容器内80端口直接对应宿主机80端口 docker run -it --name test-host-container --network host nginx","none模式#none模式":"原理\nnone模式下，Docker会为容器创建独立的网络命名空间，但不会为容器配置任何网络资源（无网卡、无IP地址、无路由表），容器处于完全隔离的网络环境中，无法与外部（包括宿主机、其他容器）进行通信。\n特点\n网络隔离性最强，容器无法与任何外部网络通信；\n无网络资源开销，适用于无需网络通信的场景（如离线数据处理）；\n可手动为容器配置网卡、IP等网络资源，实现自定义网络隔离。\n使用方式\n通过--network none参数指定none模式：\n# 启动容器，使用none模式，容器无网络连接 docker run -it --name test-none-container --network none nginx","容器dns配置#容器DNS配置":"Docker容器默认继承宿主机的DNS配置（/etc/resolv.conf），也可手动指定容器的DNS服务器，解决容器无法解析域名的问题：\n# 启动容器时指定DNS服务器 docker run -it --name test-dns --dns 8.8.8.8 --dns 114.114.114.114 nginx # 查看容器的DNS配置 docker exec test-dns cat /etc/resolv.conf","概述#概述":"本文档旨在详细介绍Docker网络的核心原理、常用网络模式、配置方法及常见问题排查，为开发、运维人员提供Docker网络相关的操作指南和技术参考，帮助快速掌握Docker网络的使用与调优技巧。\n核心作用\nDocker网络是Docker容器与外部（宿主机、其他容器、互联网）进行通信的基础，其核心作用包括：\n实现容器与容器之间的互联互通，支持多容器协作部署（如前端容器与后端容器通信）；\n实现容器与宿主机之间的网络交互，支持容器访问宿主机服务或宿主机访问容器服务；\n实现容器与外部网络（互联网）的通信，支持容器对外提供服务或访问外部资源；\n隔离网络环境，通过网络策略控制容器的访问权限，保障容器运行的安全性。\n核心概念\n网络命名空间（Network Namespace）：Linux内核提供的网络隔离技术，每个Docker容器默认拥有独立的网络命名空间，包含独立的网卡、IP地址、路由表、端口等网络资源，实现容器网络环境的隔离；\n网桥（Bridge）：Docker默认的网络设备，用于连接同一宿主机上的多个容器，实现容器之间的二层通信，类似物理网络中的交换机；\n端口映射（Port Mapping）：将宿主机的端口映射到容器的端口，实现外部网络通过宿主机端口访问容器内部服务；\nIP地址分配：Docker会为每个容器自动分配IP地址（默认从私有网段中分配），也支持手动指定固定IP；\n网络驱动（Network Driver）：Docker网络的核心组件，不同的驱动对应不同的网络模式，实现不同的通信场景（如桥接、Host、Overlay等）。","端口映射配置#端口映射配置":"当容器需要对外提供服务（如web服务、数据库服务）时，需配置端口映射，将宿主机的端口映射到容器的端口，外部网络通过宿主机IP+映射端口访问容器服务。\n指定端口\ndocker run -it -p 8080:80 --name test-port-container nginx 绑定指定IP的端口映射\n# 绑定宿主机192.168.1.100的8080端口到容器80端口 docker run -it -p 192.168.1.100:8080:80 nginx # 绑定宿主机本地回环IP（127.0.0.1），仅允许宿主机内部访问容器 docker run -it -p 127.0.0.1:8080:80 nginx"},"title":"Docker网络"},"/docs/%E5%AE%B9%E5%99%A8/docker%E9%85%8D%E7%BD%AE/":{"data":{"":"/etc/docker/daemon.json 是 Docker 守护进程（dockerd）的核心配置文件，用于自定义 Docker 的运行参数（如镜像加速、网络、存储、日志等）。默认情况下该文件可能不存在，需手动创建并配置，修改后需重启 Docker 服务生效。","1-文件格式#1. 文件格式":"严格遵循 JSON 语法（键值对、逗号分隔、字符串用双引号）。\n注释：JSON 本身不支持注释，若需添加注释，需使用工具（如 jq）处理，或部署时移除注释。\n生效方式：修改后执行 systemctl daemon-reload \u0026\u0026 systemctl restart docker 重启 Docker 服务。\n验证配置：docker info 可查看配置是否生效（如镜像加速地址、存储驱动等）。","1-镜像加速配置最常用#1. 镜像加速配置（最常用）":"解决 Docker 拉取镜像慢的问题，优先配置国内镜像源。\n参数 类型 说明 示例 registry-mirrors 数组（字符串） 镜像仓库加速地址列表，按顺序优先级匹配 阿里云、网易云、Docker 中国官方加速 示例配置：\n{ \"registry-mirrors\": [ \"https://xxxx.mirror.aliyuncs.com\", // 阿里云专属加速（需登录阿里云容器镜像服务获取） \"https://hub-mirror.c.163.com\", // 网易云加速（公开） \"https://docker.mirrors.ustc.edu.cn\" // 中科大加速（公开） ] }","2-网络配置#2. 网络配置":"自定义 Docker 网络相关参数（如默认网段、端口映射范围、DNS 等）。\n参数 类型 说明 示例 bip 字符串 桥接网络（bridge）的默认网关和子网 \"bip\": \"172.17.0.1/16\"（默认是 172.17.0.1/16） default-address-pools 数组 自定义 Docker 网络地址池（避免与内网网段冲突） 见下方示例 dns 数组（字符串） 容器默认 DNS 服务器列表 \"dns\": [\"223.5.5.5\", \"8.8.8.8\"]（阿里云 DNS + Google DNS） dns-search 数组（字符串） DNS 搜索域（容器内解析域名时自动拼接） \"dns-search\": [\"docker.internal\", \"company.com\"] ipv6 布尔值 是否启用 IPv6 支持 \"ipv6\": true fixed-cidr-v6 字符串 IPv6 固定子网 \"fixed-cidr-v6\": \"2001:db8::/64\" port-range 字符串 允许 Docker 映射的端口范围（默认 49153-65535） \"port-range\": \"30000-32767\" 示例配置（解决网段冲突）：\n{ \"bip\": \"172.31.0.1/16\", // 自定义 bridge 网络网关和子网 \"default-address-pools\": [ { \"base\": \"172.32.0.0/16\", \"size\": 24 }, { \"base\": \"172.33.0.0/16\", \"size\": 24 } ], \"dns\": [\"223.5.5.5\", \"8.8.8.8\"] }","2-默认配置路径#2. 默认配置路径":"Linux：/etc/docker/daemon.json\nWindows：C:\\ProgramData\\docker\\config\\daemon.json\nmacOS（Docker Desktop）：通过 GUI 配置（偏好设置 → Docker Engine），底层对应 ~/.docker/daemon.json","3-存储配置#3. 存储配置":"自定义 Docker 存储驱动、数据存储路径、镜像和容器限制等。\n参数 类型 说明 示例 data-root 字符串 Docker 数据存储根目录（默认 /var/lib/docker） \"data-root\": \"/data/docker\"（迁移 Docker 数据到 /data 分区） storage-driver 字符串 存储驱动（推荐 overlay2，Docker 18.09+ 默认） \"storage-driver\": \"overlay2\" storage-opts 数组（字符串） 存储驱动额外参数（如 overlay2 的日志大小限制） \"storage-opts\": [\"overlay2.override_kernel_check=true\", \"overlay2.size=100G\"] max-concurrent-downloads 整数 同时下载镜像的最大线程数（默认 3，提升下载速度） \"max-concurrent-downloads\": 10 max-concurrent-uploads 整数 同时上传镜像的最大线程数（默认 5） \"max-concurrent-uploads\": 5 log-driver 字符串 容器日志驱动（默认 json-file，可选 journald、syslog、fluentd 等） \"log-driver\": \"json-file\" log-opts 对象 日志驱动参数（如日志大小、滚动数量） 见下方示例 示例配置（存储优化 + 日志限制）：\n{ \"data-root\": \"/data/docker\", // 迁移数据目录到大容量分区 \"storage-driver\": \"overlay2\", \"storage-opts\": [\"overlay2.size=100G\"], // 每个容器最大磁盘占用 100G \"max-concurrent-downloads\": 10, // 加速镜像下载 \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"10m\", // 单个日志文件最大 10MB \"max-file\": \"3\" // 最多保留 3 个日志文件（滚动删除） } }","4-安全配置#4. 安全配置":"限制 Docker 权限、启用 TLS 认证、配置信任镜像仓库等。\n参数 类型 说明 示例 tls 布尔值 是否启用 TLS 认证（远程访问 Docker 时加密） \"tls\": true tlscacert 字符串 TLS 根证书路径 \"tlscacert\": \"/etc/docker/ca.pem\" tlscert 字符串 TLS 客户端证书路径 \"tlscert\": \"/etc/docker/cert.pem\" tlskey 字符串 TLS 客户端密钥路径 \"tlskey\": \"/etc/docker/key.pem\" tlsverify 布尔值 是否验证服务端证书 \"tlsverify\": true insecure-registries 数组（字符串） 信任的非 HTTPS 镜像仓库（如私有仓库） \"insecure-registries\": [\"192.168.1.100:5000\"] allow-nondistributable-artifacts 数组（字符串） 允许推送非分布式镜像到指定仓库 \"allow-nondistributable-artifacts\": [\"192.168.1.100:5000\"] live-restore 布尔值 Docker 守护进程重启时，保持容器运行（避免服务中断） \"live-restore\": true 示例配置（私有仓库信任 + TLS 认证）：\n{ \"insecure-registries\": [\"192.168.1.100:5000\"], // 信任内网 HTTP 私有仓库 \"tls\": true, \"tlscacert\": \"/etc/docker/ca.pem\", \"tlscert\": \"/etc/docker/server-cert.pem\", \"tlskey\": \"/etc/docker/server-key.pem\", \"tlsverify\": true, \"live-restore\": true // 守护进程重启不影响运行中的容器 }","5-资源限制配置#5. 资源限制配置":"限制 Docker 占用的系统资源（CPU、内存、PID 等）。\n参数 类型 说明 示例 default-shm-size 字符串 容器默认共享内存大小（默认 64M，部分服务如 Chrome、Elasticsearch 需增大） \"default-shm-size\": \"2G\" oom-score-adjust 整数 Docker 守护进程的 OOM 优先级（-1000 到 1000，数值越低越不容易被 OOM 杀死） \"oom-score-adjust\": -1000 max-pids 整数 所有容器的最大 PID 总数限制（避免容器占用过多进程） \"max-pids\": 10000 cpu-shares 整数 Docker 整体 CPU 权重（相对值，默认 1024） \"cpu-shares\": 2048 memory-limit 字符串 Docker 整体内存限制（默认无限制） \"memory-limit\": \"16G\" 示例配置（资源限制）：\n{ \"default-shm-size\": \"2G\", // 默认共享内存 2G \"oom-score-adjust\": -1000, // 避免 Docker 被 OOM 杀死 \"max-pids\": 10000, // 最大进程数 10000 \"memory-limit\": \"16G\" // 限制 Docker 总内存占用不超过 16G }","6-其他实用配置#6. 其他实用配置":"参数 类型 说明 示例 experimental 布尔值 是否启用 Docker 实验性特性（如 Buildx、IPv6 等） \"experimental\": true features 对象 启用特定特性（如 buildkit 构建引擎） \"features\": {\"buildkit\": true} labels 数组（字符串） 给 Docker 守护进程添加标签（用于集群管理） \"labels\": [\"env=production\", \"owner=devops\"] log-level 字符串 日志级别（debug/info/warn/error/fatal，默认 info） \"log-level\": \"warn\"","一配置文件基础说明#一、配置文件基础说明":"","二核心配置参数详解按功能分类#二、核心配置参数详解（按功能分类）":""},"title":"Docker配置"},"/docs/%E5%AE%B9%E5%99%A8/docker-compose%E5%9F%BA%E7%A1%80/":{"data":{"":"","持久化配置#持久化配置":"使用宿主机目录或文件挂载\nvolumes: - ./conf:/etc/nginx/conf.d - ./conf/default.conf:/etc/nginx/conf.d/default.conf 使用volume\nvolumes: - nginx_conf:/etc/nginx/conf.d volumes: nginx_conf: 指定存储名称和挂载类型\nvolumes: - nginx_conf:/etc/nginx/conf.d volumes: nginx_conf: name: conf driver: local 使用已有存储\nvolumes: - existing_volume:/app/data volumes: existing_volume: external: true name: pre-existing-volume-name 使用volumes卷, 挂载自定义目录\nvolumes: - nginx_test:/etc/nginx/conf.d volumes: nginx_test: driver: local driver_opts: type: none o: bind device: /data/nginx/conf.d 远程挂载\nvolumes: # NFS 驱动 nfs_volume: driver: local driver_opts: type: nfs device: \":/nfs/share/data\" o: \"addr=192.168.1.100,nfsvers=4,hard,intr\" # SMB/CIFS 驱动 smb_volume: driver: local driver_opts: type: cifs device: \"//server/share\" o: \"username=user,password=pass,file_mode=0777,dir_mode=0777\" # 临时内存卷 tmpfs_volume: driver: local driver_opts: type: tmpfs device: tmpfs o: \"size=100m,uid=1000\"","示例#示例":"version: '3.8' # 自定义网络 networks: app-network: driver: bridge ipam: config: - subnet: 172.30.0.0/16 gateway: 172.30.0.1 # 持久化卷 volumes: mysql-data: driver: local driver_opts: type: none o: bind device: ./mysql-data # 服务定义 services: # Web 服务 nginx: image: nginx:alpine container_name: my-nginx ports: - \"80:80\" - \"443:443\" volumes: - ./nginx.conf:/etc/nginx/nginx.conf:ro - ./html:/usr/share/nginx/html networks: - app-network restart: unless-stopped healthcheck: test: [\"CMD\", \"wget\", \"-qO-\", \"http://localhost\"] interval: 30s timeout: 10s retries: 3 depends_on: - php # 数据库服务 mysql: image: mysql:8.0 container_name: my-mysql environment: MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: app_db volumes: - mysql-data:/var/lib/mysql networks: - app-network deploy: resources: limits: cpus: \"1\" memory: 1G reservations: cpus: \"0.5\" memory: 512M restart: on-failure:3 # 扩展字段（复用配置） x-common-env: \u0026common-env TZ: Asia/Shanghai LANG: en_US.UTF-8","示例配置#示例配置":"基础运行yaml\nservices: nginx: image: nginx container_name: nginx restart: unless-stopped environment: ENV_TEST: 123456 ports: - \"80:80\" volumes: - ./html:/usr/share/nginx/html","网络选择#网络选择":"使用已有网络\n# 使用已有自定义网络, 类型bridge network_mode: app-network # 使用host网络 network_mode: host # 使用bridge网络 network_mode: bridge 使用自定义网络,不指定网段\nnetworks: - app-network networks: app-network: driver: bridge 使用自定义网络,并自定义网段\nnetworks: - app-network networks: app-network: driver: bridge ipam: config: - subnet: 172.30.0.0/16 gateway: 172.30.0.1 使用自定义网络,并自定义网段和ip\nnetworks: app_net: ipv4_address: 172.30.0.2 networks: app-network: driver: bridge ipam: config: - subnet: 172.30.0.0/16 gateway: 172.30.0.1","资源限制#资源限制":"限制内存\nmem_limit: 2000M cpu和内存\ndeploy: resources: limits: cpus: \"1\" memory: 1G reservations: cpus: \"0.5\" memory: 512M 文件打开数\nsysctls: - net.core.somaxconn=65535 ulimits: nofile: soft: 100000 hard: 100000","配置文件核心结构#配置文件核心结构":"Docker Compose 配置文件（docker-compose.yml/compose.yml）基于 YAML 格式，核心分为 五大模块：services（服务，必选）、networks（网络）、volumes（卷）、configs（配置）、secrets（密钥），另支持顶层全局参数和自定义扩展字段，以下是所有支持的参数详细说明。\n顶层参数作用于整个 Compose 项目，定义项目的基础配置和全局资源。\n参数 说明 version 指定 Compose 文件格式版本（推荐 3.8+，适配 Docker 20.10+），不同版本支持的参数存在兼容性差异，3.x 版本适配 Swarm 模式，2.x 偏向单机使用 services 定义所有容器服务（核心必选模块），下属每个子项为一个独立容器服务，包含容器运行的所有配置 networks 定义自定义网络，用于服务间网络隔离、通信，支持多种网络驱动，需在服务中通过 networks 关联 volumes 定义持久化数据卷，用于容器数据持久化（容器删除后数据不丢失），支持本地卷、网络卷等，需在服务中通过 volumes 挂载 configs Docker Swarm 模式专用，定义跨服务共享的配置文件（非敏感信息），支持本地文件加载或引用外部配置 secrets Docker Swarm 模式专用，定义敏感信息（密码、密钥等），避免明文暴露，支持本地文件加载或引用外部密钥 x-* 自定义扩展字段，字段名必须以 x- 开头（如 x-common-env），Compose 会忽略该字段，但可通过 YAML 锚点语法复用配置"},"title":"Docker Compose基础"},"/docs/%E5%AE%B9%E5%99%A8/dockerfile%E5%9F%BA%E7%A1%80/":{"data":{"":"","一dockerfile-指令核心分类#一、Dockerfile 指令核心分类":"Dockerfile 是构建 Docker 镜像的文本文件，指令按功能可分为 7 大核心模块，涵盖基础镜像选择、构建参数配置、文件操作、环境配置、运行命令、容器启动设置等全流程，所有指令大小写不敏感，但惯例使用大写以区分参数。","七安全与资源控制模块#七、安全与资源控制模块":"该模块指令用于配置容器运行时的安全策略、资源限制、内核参数，提升容器运行的安全性和稳定性。\n指令 说明 SECURITY_OPT 设置容器的安全选项，用于限制容器的权限、启用安全机制（如 --security-opt seccomp=profile.json 启用自定义 seccomp 安全配置，--security-opt apparmor=profile 启用 AppArmor 配置）；语法：SECURITY_OPT [\"\u003c选项1\u003e\", \"\u003e\"]；用于增强容器安全性，限制容器对主机的访问权限 CAP_ADD 为容器添加 Linux 内核能力（Capabilities），默认容器仅拥有部分基础能力；常见能力：NET_ADMIN（网络管理权限）、SYS_TIME（修改系统时间权限）、DAC_READ_SEARCH（读取任意文件权限）；语法：CAP_ADD [\"\u003c能力1\u003e\", \"2\u003e\"]（如 CAP_ADD [\"NET_ADMIN\"]）；仅授予必要能力，避免过度授权 CAP_DROP 从容器中移除 Linux 内核能力，与 CAP_ADD 配合使用，最小化容器权限；支持 CAP_DROP ALL（移除所有能力，仅保留默认最小能力集）；语法：CAP_DROP [\"\u003c能力1\u003e\", \"\u003c能力2\u003e\"]（如 CAP_DROP [\"SETUID\", \"SETGID\"]） SYSCTL 配置容器运行时的内核参数（仅在 Linux 镜像中生效），用于优化容器网络、内存等性能；语法：SYSCTL [\"\u003c参数1\u003e=\u003e\", \"\u003c参数2\u003e=\u003c值2\u003e\"]（如 SYSCTL [\"net.ipv4.ip_forward=1\", \"net.core.somaxconn=1024\"]）；需确保内核参数支持容器级配置，部分参数需主机内核开启相关功能 USER --root 扩展 USER 指令，强制以 root 用户执行后续指令（如 USER --root RUN apt update），用于需要临时提升权限的场景，执行完成后可切换回普通用户，平衡安全性和操作便利性","三文件操作与目录配置模块#三、文件操作与目录配置模块":"该模块指令用于在镜像中复制文件、创建目录、设置工作目录，控制镜像内的文件结构。\n指令 说明 COPY 将本地主机的文件 / 目录复制到镜像的指定路径；支持通配符（如 COPY *.txt /app/）；复制时保持源文件的权限属性；如果目标路径不存在，会自动创建；语法：COPY \u003c源路径\u003e... \u003c目标路径\u003e 或 COPY [\"\u003e\", \" ..., \"\"]（源路径含空格时需用引号包裹） ADD 功能与 COPY 类似，额外支持：1. 自动解压本地压缩文件（如 .tar、.gz、.zip）到目标路径；2. 支持 URL 作为源路径，自动下载文件到目标路径（不推荐，建议用 RUN wget/curl 替代，便于控制下载过程）；语法与 COPY 一致 WORKDIR 设置容器启动后的默认工作目录，后续的 RUN、CMD、ENTRYPOINT、COPY、ADD 等指令会在该目录下执行；如果目录不存在，会自动创建；支持多次使用（每次使用会切换到新目录，如 WORKDIR /app → WORKDIR src，最终工作目录为 /app/src）；路径支持相对路径和绝对路径 VOLUME 声明容器运行时的持久化数据卷（仅声明，实际挂载需在 docker run 时指定主机路径或命名卷）；用于存储容器运行时产生的动态数据（如数据库文件、日志），避免容器删除后数据丢失；支持单个路径（如 VOLUME /data）或多个路径（如 VOLUME [\"/data\", \"/logs\"]）；声明的卷在容器启动时会自动创建，且权限为 root:root","九示例#九、示例":"# ===================== 第一阶段：构建阶段（多阶段构建核心）===================== # 指定构建基础镜像，带版本锁定+镜像别名，适配多阶段复用 FROM maven:3.9.6-openjdk-17-slim AS builder # 设置构建阶段的工作目录（核心指令，统一后续操作路径） WORKDIR /app/build # 声明元数据：镜像作者（Name 规范格式） LABEL maintainer=\"DevOps-Team \" # 声明元数据：镜像描述、版本、应用类型（标准化镜像标识） LABEL org.opencontainers.image.title=\"Java-Backend-Service\" LABEL org.opencontainers.image.description=\"Production-grade Java microservice with full optimizations\" LABEL org.opencontainers.image.version=\"v2.1.0\" LABEL org.opencontainers.image.authors=\"devops-team\" # 声明元数据：镜像开源协议、仓库地址 LABEL org.opencontainers.image.licenses=\"MIT\" LABEL org.opencontainers.image.source=\"https://github.com/xxx/java-service\" # 1. COPY 指令多参数演示：--chown（指定文件属主）、通配符、多源复制 # 复制Maven配置文件（优先下载依赖，利用Docker分层缓存，提升构建效率） COPY --chown=1000:1000 pom.xml ./ COPY --chown=1000:1000 settings.xml /usr/share/maven/conf/ # 2. RUN 指令多参数演示：\\换行拼接、\u0026\u0026 链式执行、管道符、apt包管理全参数 # 安装构建依赖+清理缓存，减少镜像体积；指定DEBIAN_FRONTEND避免交互 RUN apt-get update \\ \u0026\u0026 DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends git curl wget \\ \u0026\u0026 apt-get clean \\ \u0026\u0026 rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* # 下载Maven依赖（分层缓存核心：依赖不变则该层不重建） RUN mvn dependency:go-offline -B # 复制项目源码（源码变动仅重建该层及后续层） COPY --chown=1000:1000 src/ ./src/ # 打包项目：跳过测试、指定编码、输出可执行Jar包 RUN mvn clean package -DskipTests -Dfile.encoding=UTF-8 -Dmaven.compiler.source=17 -Dmaven.compiler.target=17 # ===================== 第二阶段：运行阶段（精简镜像，生产环境规范）===================== # 选型轻量级基础镜像（Alpine版，体积仅几十MB，比slim更精简），指定具体版本避免漂移 FROM openjdk:17-jdk-alpine3.19 AS production # 设置时区（解决容器内时区与宿主机不一致问题，生产必配） ENV TZ=Asia/Shanghai # 3. ENV 指令多参数演示：批量设置环境变量（应用配置、JVM调优、路径配置） # 应用核心配置 ENV APP_NAME=java-service \\ APP_PORT=8080 \\ SPRING_PROFILES_ACTIVE=prod \\ # JVM性能调优参数（生产级，适配容器内存限制） JAVA_OPTS=\"-Xms512m -Xmx1024m -XX:+UseContainerSupport -XX:MaxRAMPercentage=80.0\" \\ # 应用工作路径 APP_HOME=/app/runtime # 4. ARG 指令演示：构建时参数（仅构建阶段生效，可通过 docker build --build-arg 传参） # 定义运行时用户ID/组ID，支持构建时自定义 ARG RUN_USER=appuser ARG RUN_UID=1000 ARG RUN_GID=1000 # 创建非root用户+组（生产安全规范：禁止容器以root运行，降低权限风险） RUN addgroup --gid ${RUN_GID} ${RUN_USER} \\ \u0026\u0026 adduser --uid ${RUN_UID} --gid ${RUN_GID} --disabled-password --gecos \"\" ${RUN_USER} # 创建应用工作目录+授权（指定属主，避免权限问题） RUN mkdir -p ${APP_HOME}/logs ${APP_HOME}/conf \\ \u0026\u0026 chown -R ${RUN_USER}:${RUN_USER} ${APP_HOME} # 切换工作目录（后续指令默认在此路径执行） WORKDIR ${APP_HOME} # 5. COPY --from 多阶段复制核心：从builder阶段复制打包产物，仅保留运行必需文件 COPY --from=builder --chown=${RUN_USER}:${RUN_USER} /app/build/target/*.jar ${APP_HOME}/app.jar # 6. USER 指令：切换为非root用户（生产必配，完成权限降级） USER ${RUN_USER} # 7. EXPOSE 指令：声明容器对外暴露的端口（TCP协议，生产规范：仅声明，不映射） # 支持多端口声明，区分应用端口、监控端口 EXPOSE ${APP_PORT}/tcp 9100/tcp # 8. VOLUME 指令：声明持久化数据卷（日志、配置、数据，实现容器数据与容器解耦） # 容器销毁后，卷内数据可保留，支持宿主机挂载/容器间共享 VOLUME [\"${APP_HOME}/logs\", \"${APP_HOME}/conf\", \"/tmp\"] # 9. HEALTHCHECK 健康检查指令（生产必配，Docker容器自愈核心） # --interval：检查间隔（30秒）、--timeout：超时时间（5秒）、--retries：重试次数（3次）、--start-period：启动等待时间（60秒） # 检查逻辑：通过curl访问健康接口，返回200则健康，否则不健康 HEALTHCHECK --interval=30s --timeout=5s --retries=3 --start-period=60s \\ CMD curl -f http://localhost:${APP_PORT}/actuator/health || exit 1 # 10. ENTRYPOINT + CMD 组合（生产最优解：ENTRYPOINT固定执行逻辑，CMD传默认参数） # ENTRYPOINT：不可被docker run命令行参数覆盖，保证启动脚本固定 # CMD：可被docker run参数覆盖，支持启动参数自定义 ENTRYPOINT [\"java\", \"-jar\"] CMD [\"app.jar\"]","二基础镜像与构建阶段模块#二、基础镜像与构建阶段模块":"该模块指令用于指定构建的基础镜像、构建阶段划分及跨平台适配，是镜像构建的起点。\n指令 说明 FROM 必选指令，指定构建的基础镜像（格式：镜像名:标签），所有后续指令基于该镜像执行；支持 `AS 语法，用于多阶段构建（不同阶段可使用不同基础镜像，最终仅保留目标阶段内容，减小镜像体积） FROM --platform 扩展 FROM 指令，指定基础镜像的目标架构（如 linux/amd64、linux/arm64、windows/amd64），适配多架构镜像构建，解决跨平台部署问题 ARG 定义构建阶段专用参数，仅在 docker build 过程中生效，容器运行时不可用；支持设置默认值（如 ARG APP_VERSION=1.0），可通过 docker build --build-arg \u003c参数名\u003e=\u003e 命令覆盖默认值；ARG 指令需在引用它的指令之前定义，且在 FROM 之前定义的 ARG 仅能在 FROM 指令中使用 FROM --build-arg 结合 ARG 使用，在指定基础镜像时传递构建参数（如 FROM --build-arg HTTP_PROXY=xxx ubuntu:22.04），用于基础镜像构建过程中的参数配置","五运行命令与依赖安装模块#五、运行命令与依赖安装模块":"该模块指令用于在构建镜像时执行命令（如安装依赖、编译程序、配置系统），指令执行结果会被固化到镜像层。\n指令 说明 RUN 构建阶段执行命令，每个 RUN 指令会创建一个新的镜像层；支持两种格式：1. 壳层格式（RUN \u003c命令\u003e）：通过默认 shell 执行（如 /bin/sh -c），支持管道、变量替换等壳层特性（如 RUN apt update \u0026\u0026 apt install -y nginx）；2. exec 格式（RUN [\"\u003c可执行文件\u003e\", \"\u003c参数1\u003e\", \"\u003e\"]）：直接执行可执行文件，不通过 shell，避免字符转义问题，且信号能直接传递（如 RUN [\"/usr/bin/wget\", \"https://example.com/file.tar.gz\"]）；建议将多个相关命令合并为一个 RUN 指令（用 \u0026\u0026 连接），减少镜像层数，减小镜像体积 RUN --mount 构建阶段临时挂载文件系统（仅在当前 RUN 指令执行期间有效，指令结束后挂载消失），用于构建时的依赖缓存、秘密数据挂载等场景；支持多种挂载类型：type=bind（绑定本地目录）、type=cache（缓存目录，加速多次构建）、type=secret（挂载秘密文件，避免明文暴露）、type=tmpfs（临时文件系统）；语法：RUN --mount=type=\u003c类型\u003e,src=路径\u003e,dst=\u003e RUN –mount=type=cache,target=/var/cache/apt apt update \u0026\u0026 apt install -y nginx`） RUN --network 控制 RUN 指令执行时的网络模式（如 --network=none 禁用网络，--network=host 共享主机网络，--network=连接指定网络）；默认网络模式为 default`（容器网络）；用于控制构建过程中是否允许网络访问（如禁用网络以确保构建不依赖外部资源）","八多阶段构建专用模块#八、多阶段构建专用模块":"该模块指令仅用于多阶段构建，实现构建过程与运行环境分离，减小最终镜像体积。\n指令 说明 COPY --from 多阶段构建专用，从之前命名的构建阶段复制文件到当前阶段（如 COPY --from=builder /app/bin/app /usr/local/bin/）；builder 为前一阶段的 FROM AS 定义的名称；支持从外部镜像复制文件（如 COPY –from=nginx:alpine /etc/nginx/nginx.conf/app/`）；核心作用是仅保留运行时必需的文件（如编译后的程序），丢弃构建时的依赖（如编译器、源代码），大幅减小镜像体积 FROM --from 多阶段构建专用，指定当前阶段的基础镜像为前一构建阶段（如 FROM --from=builder alpine:3.18），用于基于前一阶段的构建结果继续构建，适用于复杂的分层构建场景","六容器启动配置模块#六、容器启动配置模块":"该模块指令用于设置容器启动时的默认行为（如启动命令、入口点、暴露端口），影响容器运行时的初始状态。\n指令 说明 CMD 指定容器启动时的默认命令，容器启动后仅执行一次；支持三种格式：1. 壳层格式（CMD ：通过默认 shell 执行（如 CMD nginx -g ‘daemon off;’）；2. exec 格式（CMD [\"\"\u003c 参数 1\u003e\", “2\u003e”]）：推荐格式，直接执行可执行文件（如 CMD [“nginx”, “-g”, “daemon off;”]）；3. 参数格式（CMD [\"\u003c 参数 1\u003e\", “\u003e”]）：配合 ENTRYPOINT使用，为入口点传递默认参数；一个 Dockerfile 中仅能有一个CMD指令，多个CMD 仅最后一个生效；docker run命令后指定的参数会覆盖CMD` 的默认值 ENTRYPOINT 定义容器的入口点（即容器启动时执行的可执行程序），与 CMD 配合使用时，CMD 仅作为参数传递给 ENTRYPOINT；支持两种格式：1. exec 格式（ENTRYPOINT [\"\u003c可执行文件\u003e\", \"1\u003e\", ...]）：推荐格式，信号可直接传递，容器启动后进程为 PID 1；2. 壳层格式（ENTRYPOINT \u003e）：通过 shell 执行，进程不会成为 PID 1，可能影响信号处理（如 docker stop 无法正常终止进程）；一个 Dockerfile 中仅能有一个 ENTRYPOINT 指令，多个 ENTRYPOINT 仅最后一个生效；docker run --entrypoint 命令可覆盖 ENTRYPOINT 的默认值 EXPOSE 声明容器运行时对外暴露的端口（仅为文档说明作用，不实际映射端口到主机）；用于告知使用者容器的服务端口，便于 docker run -p 映射；支持单个端口（EXPOSE 80）、多个端口（EXPOSE 80 443）、指定协议（EXPOSE 80/tcp 80/udp，默认 TCP）；即使不声明 EXPOSE，docker run -p 仍可映射端口 HEALTHCHECK 定义容器健康检查规则，用于判断容器内服务是否正常运行；支持两种格式：1. HEALTHCHECK [选项] CMD （如 HEALTHCHECK –interval=30s –timeout=10s –retries=3 CMD curl -f http://localhost","四环境配置模块#四、环境配置模块":"该模块指令用于配置容器运行时的环境变量、用户权限、内核参数等，影响容器运行状态。\n指令 说明 ENV 设置容器运行时的环境变量（构建阶段和运行阶段均生效）；支持两种格式：ENV \u003c键\u003e=\u003c值\u003e（单个变量）或 ENV \u003e \u003c值1\u003e \u003c键2\u003e \u003e（多个变量）；后续指令（RUN、CMD 等）可直接引用（如 ENV PATH=/app/bin:$PATH）；容器运行时可通过 docker run -e \u003c值\u003e 覆盖默认值 USER 指定容器运行时的用户（默认以 root 用户运行）；支持用户名、UID、UID:GID 格式（如 USER appuser、USER 1000、USER 1000:1000）；使用非 root 用户可提高容器安全性；USER 指令之后的所有指令（RUN、CMD 等）都会以该用户身份执行；如需切换回 root 用户，可再次使用 USER root SHELL 指定容器内的默认 shell 程序，用于 RUN、CMD、ENTRYPOINT 等指令的命令执行；默认 shell：Linux 镜像为 /bin/sh -c，Windows 镜像为 cmd /S /C；语法：SHELL [\"\", \"\u003c参数\u003e\"]（如 SHELL [\"/bin/bash\", \"-c\"]，让 RUN 指令使用 bash 执行命令） ENV --unset 移除已设置的环境变量（如 ENV --unset HTTP_PROXY），用于清理构建过程中临时设置的环境变量，减少镜像冗余 LABEL 为镜像添加元数据标签（键值对格式），用于分类、筛选、说明镜像信息（如作者、版本、用途）；支持单个标签（LABEL maintainer=devops@example.com）或多个标签（LABEL com.example.version=1.0 com.example.env=prod）；可通过 docker inspect \u003e 查看标签信息；多个 LABEL 指令会合并为一个，建议集中编写","补充说明#补充说明":"指令执行顺序：Dockerfile 指令按从上到下的顺序执行，FROM 指令必须是第一个非注释指令；\n镜像层优化：RUN、COPY、ADD 指令会创建新的镜像层，层数越多镜像体积越大，建议合并相关 RUN 指令，避免无用文件复制；\n注释语法：使用 # 开头表示注释（如 # 安装 Nginx），注释仅用于说明，不会被执行；\n官方文档参考：所有指令的最新说明可查阅 Docker 官方文档：Dockerfile Reference"},"title":"Dockerfile基础"},"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/":{"data":{"":"redis mongo mysql sqlite"},"title":"数据库"},"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/":{"data":{"":"关于mongo的技术文档。"},"title":"Mongo"},"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/mongo%E5%AE%89%E8%A3%85/":{"data":{"":"","启动#启动":"docker compose up -d ​","部署#部署":"docker-compose.yamlcat \u003e docker-compose.yaml \u003c"},"title":"Mongo安装"},"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/":{"data":{"":"关于mysql的技术文档。"},"title":"Mysql"},"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%89%E8%A3%85/":{"data":{"":"mysql 部署，如果要部署5.7版本，镜像版本改为：mysql:5.7.28即可\ndocker-compose.yamlcat \u003e docker-compose.yaml \u003c","启动#启动":"docker compose up -d ​"},"title":"Mysql安装"},"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/":{"data":{"":"关于redis的技术文档。"},"title":"Redis"},"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4/":{"data":{"":"","备份#备份":"cp data","恢复#恢复":"","扩容#扩容":"redis-cli -a moxigame --cluster add-node 10.0.1.247:17004 10.0.1.247:17001","缩容#缩容":"缩容从节点\n# 移除从节点（格式：redis-cli --cluster del-node 集群节点地址 要下线的节点ID） redis-cli -a moxigame --cluster del-node 10.0.1.247:17001 c9f280b217c2fdb9713732f527781ebef9d9f909 # 查看集群节点列表，确认 17004 已不存在 redis-cli -a moxigame -c -p 17001 cluster nodes | grep 17004 # 查看集群状态，确保正常 redis-cli -a moxigame -c -p 17001 cluster info | grep cluster_state # 输出 cluster_state:ok 缩容主节点\n# 连接集群，查看 17003 主节点信息 redis-cli -a moxigame -c -p 17001 cluster nodes | grep 17003 # 输出示例： # 04d6252fe6ca1f48b3a4cd7ca37baa1c817a8786 10.0.1.247:17003@27003 myself,master - 0 1769133219646 3 connected 10923-16383 # 记录：主节点 ID=04d6252fe6ca1f48b3a4cd7ca37baa1c817a8786，哈希槽=10923-16383 # 进入任意主节点容器（如 17001） docker exec -it redis-node-1 bash # 执行槽位迁移（以迁移 17003 的 5461 个槽到 17001 为例） redis-cli -a moxigame --cluster reshard 10.0.1.247:17001 交互步骤（按提示输入）： How many slots do you want to move (from 1 to 16384)? → 输入 5461（17003 持有的槽数，10923-16383 共 5461 个）； What is the receiving node ID? → 输入目标主节点 ID（如 17001 的 ID：234a5b1659e4142eee6d1e76a2f82a754eb909f9）； Source node #1: → 输入源主节点 ID（17003 的 ID：04d6252fe6ca1f48b3a4cd7ca37baa1c817a8786）； Source node #2: → 输入 done（表示仅从 17003 迁移）； Do you want to proceed with the proposed reshard plan (yes/no)? → 输入 yes。\n迁移完成验证：\n# 查看 17003 的槽位，确认已无槽位 redis-cli -a moxigame -c -p 17001 cluster nodes | grep 17003 # 输出中无 \"connected 10923-16383\" 表示槽位迁移完成 验证\n# 1. 查看集群节点，确认 17003/17006 已移除 redis-cli -a moxigame -c -p 17001 cluster nodes | grep -E \"17003|17006\" # 无输出表示移除成功 # 2. 验证哈希槽全部分配 redis-cli -a moxigame -c -p 17001 cluster info | grep cluster_slots_assigned # 输出 cluster_slots_assigned:16384 表示槽位无丢失 # 3. 测试数据读写（访问原 17003 的槽位） redis-cli -a moxigame -c -p 17001 set test_reshard \"success\" redis-cli -a moxigame -c -p 17001 get test_reshard # 输出 \"success\" 表示读写正常","部署#部署":"三主三从配置\nservices: redis-node-1: image: docker.io/redis:5.0.5 container_name: redis-node-1 command: redis-server --cluster-enabled yes --cluster-config-file nodes.conf --cluster-node-timeout 5000 --cluster-migration-barrier 1 --cluster-require-full-coverage no --appendonly yes --port 17001 --requirepass moxigame --masterauth moxigame network_mode: host volumes: - ./data/node-1:/data restart: unless-stopped redis-node-2: image: docker.io/redis:5.0.5 container_name: redis-node-2 command: redis-server --cluster-enabled yes --cluster-config-file nodes.conf --cluster-node-timeout 5000 --cluster-migration-barrier 1 --cluster-require-full-coverage no --appendonly yes --port 17002 --requirepass moxigame --masterauth moxigame network_mode: host volumes: - ./data/node-2:/data restart: unless-stopped redis-node-3: image: docker.io/redis:5.0.5 container_name: redis-node-3 command: redis-server --cluster-enabled yes --cluster-config-file nodes.conf --cluster-node-timeout 5000 --cluster-migration-barrier 1 --cluster-require-full-coverage no --appendonly yes --port 17003 --requirepass moxigame --masterauth moxigame network_mode: host volumes: - ./data/node-3:/data restart: unless-stopped redis-node-4: image: docker.io/redis:5.0.5 container_name: redis-node-4 command: redis-server --cluster-enabled yes --cluster-config-file nodes.conf --cluster-node-timeout 5000 --cluster-migration-barrier 1 --cluster-require-full-coverage no --appendonly yes --port 17004 --requirepass moxigame --masterauth moxigame network_mode: host volumes: - ./data/node-4:/data restart: unless-stopped redis-node-5: image: docker.io/redis:5.0.5 container_name: redis-node-5 command: redis-server --cluster-enabled yes --cluster-config-file nodes.conf --cluster-node-timeout 5000 --cluster-migration-barrier 1 --cluster-require-full-coverage no --appendonly yes --port 17005 --requirepass moxigame --masterauth moxigame network_mode: host volumes: - ./data/node-5:/data restart: unless-stopped redis-node-6: image: docker.io/redis:5.0.5 container_name: redis-node-6 command: redis-server --cluster-enabled yes --cluster-config-file nodes.conf --cluster-node-timeout 5000 --cluster-migration-barrier 1 --cluster-require-full-coverage no --appendonly yes --port 17006 --requirepass moxigame --masterauth moxigame network_mode: host volumes: - ./data/node-6:/data restart: unless-stopped 运行\ndocker compose up -d 创建集群\nredis-cli -a moxigame --cluster create 10.0.1.247:17001 10.0.1.247:17002 10.0.1.247:17003 10.0.1.247:17004 10.0.1.247:17005 10.0.1.247:17006 --cluster-replicas 1 --cluster-yes"},"title":"Redis分片集群"},"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%AE%89%E8%A3%85/":{"data":{"":"","启动#启动":"docker compose up -d ​","部署#部署":"docker-compose.yamlcat \u003e docker-compose.yaml \u003c"},"title":"Redis安装"},"/docs/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/":{"data":{"":"","简介#简介":"介绍一些关于网络和安全的工具和技术。"},"title":"网络安全"},"/docs/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/iptables%E4%B9%8Bnat%E9%85%8D%E7%BD%AE/":{"data":{"":"","1-web-服务映射80-端口#1. Web 服务映射（80 端口）":"# DNAT：外网访问 203.0.113.10:80 → 转发到内网 192.168.1.200:80 iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination 192.168.1.200:80","1-临时开启重启失效用于测试#1. 临时开启（重启失效，用于测试）":"echo 1 \u003e /proc/sys/net/ipv4/ip_forward","2-ssh-服务映射2222-端口映射到-22-端口#2. SSH 服务映射（2222 端口映射到 22 端口）":"# DNAT：外网访问 203.0.113.10:2222 → 转发到内网 192.168.1.200:22 iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 2222 -j DNAT --to-destination 192.168.1.200:22","2-永久开启重启生效生产环境推荐#2. 永久开启（重启生效，生产环境推荐）":"编辑内核参数配置文件：\n/etc/sysctl.confnet.ipv4.ip_forward = 1 生效配置：\nsysctl -p","3-可选放行对应端口的入站流量避免被默认策略拦截#3. 可选：放行对应端口的入站流量（避免被默认策略拦截）":"若网关 INPUT 链默认策略为 DROP，需放行映射的端口：\n# 放行外网访问 80 端口 iptables -A INPUT -i eth0 -p tcp --dport 80 -j ACCEPT # 放行外网访问 2222 端口 iptables -A INPUT -i eth0 -p tcp --dport 2222 -j ACCEPT # 放行已建立的连接（确保返回数据能通过） iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT","centosrhel-系统#CentOS/RHEL 系统":"# 保存规则到配置文件 iptables-save \u003e /etc/sysconfig/iptables # 开机自启 iptables systemctl enable iptables \u0026\u0026 systemctl restart iptables","ubuntudebian-系统#Ubuntu/Debian 系统":"# 安装规则持久化工具 apt-get install -y iptables-persistent # 保存规则（自动写入 /etc/iptables/rules.v4） netfilter-persistent save","关键参数说明#关键参数说明":"参数 作用 -t nat 指定操作 nat 表（SNAT/DNAT 均在 nat 表中配置） -A POSTROUTING 在 POSTROUTING 链添加规则（数据包路由后、发送前修改源 IP） -s 192.168.1.0/24 匹配内网网段（仅对该网段的流量生效） -o eth0 指定出站网卡（即网关的外网网卡） --to-source 203.0.113.10 替换后的源 IP（网关公网 IP）","关键参数说明-1#关键参数说明":"参数 作用 -A PREROUTING 在 PREROUTING 链添加规则（数据包路由前修改目标 IP / 端口） -i eth0 指定入站网卡（即网关的外网网卡，仅匹配外网请求） --dport 80 匹配外网请求的目标端口（网关公网 IP 的端口） --to-destination 192.168.1.200:80 转发后的内网服务器 IP 和端口","场景-1snat-配置内网主机通过网关访问外网#场景 1：SNAT 配置（内网主机通过网关访问外网）":"","场景-2dnat-配置外网访问内网服务端口映射#场景 2：DNAT 配置（外网访问内网服务，端口映射）":"","基础准备开启-ip-转发所有场景必做#基础准备：开启 IP 转发（所有场景必做）":"","常见问题与注意事项#常见问题与注意事项":"NAT 不生效？ 检查 IP 转发是否开启：cat /proc/sys/net/ipv4/ip_forward（返回 1 才正确）。\n检查规则顺序：PREROUTING 链规则在前，POSTROUTING 链在后；入站放行规则需匹配映射端口。\n检查网卡名称：确认 -i（入站）、-o（出站）网卡名称正确（用 ip addr 查看）。\n外网能访问映射服务，但内网访问公网 IP 无法访问？ 原因：内网主机访问网关公网 IP 时，DNAT 生效但返回路径未经过 SNAT，需添加 “内网访问公网 IP 映射” 规则： iptables -t nat -A PREROUTING -s 192.168.1.0/24 -d 203.0.113.10 -p tcp --dport 80 -j DNAT --to-destination 192.168.1.200:80 云服务器配置 DNAT 无效？ 云服务器（阿里云、腾讯云等）的公网 IP 是厂商提供的 “弹性 IP”，需先在云控制台配置 “端口转发” 或 “安全组”，开放对应端口，否则外网流量无法到达服务器。 批量删除 NAT 规则？ # 清空 nat 表的 PREROUTING 链（DNAT 规则） iptables -t nat -F PREROUTING # 清空 nat 表的 POSTROUTING 链（SNAT 规则） iptables -t nat -F POSTROUTING","方式-1固定公网-ip-场景网关有静态公网-ip#方式 1：固定公网 IP 场景（网关有静态公网 IP）":"# 配置 SNAT：内网网段 192.168.1.0/24 的流量，源 IP 替换为网关外网 IP（203.0.113.10） iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to-source 203.0.113.10","方式-2动态公网-ip-场景网关拨号上网ip-不固定#方式 2：动态公网 IP 场景（网关拨号上网，IP 不固定）":"用 MASQUERADE 替代 SNAT，自动适配公网 IP 变化：\n# 动态伪装内网 IP，适用于 ADSL 拨号、DHCP 获取公网 IP 的场景 iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j MASQUERADE","核心概念先明确#核心概念先明确":"SNAT（Source NAT）：修改数据包的源 IP，用于内网主机通过网关服务器访问外网（解决内网 IP 无法直接路由的问题）。\nDNAT（Destination NAT）：修改数据包的目标 IP / 端口，用于将外网请求映射到内网服务器（如发布内网服务到公网）。\n前提条件：网关服务器需开启 IP 转发功能（必须先配置，否则 NAT 不生效）。","环境假设#环境假设":"网关服务器有两块网卡：\n内网网卡：eth1，IP：192.168.1.2（内网网段：192.168.1.0/24）\n外网网卡：eth0，IP：203.0.113.10（公网 IP，可访问互联网）\n内网主机：192.168.1.100（重要：网关指向 192.168.1.2）","环境假设-1#环境假设":"网关服务器：外网网卡 eth0（IP：203.0.113.10），内网网卡 eth1（IP：192.168.1.1）\n内网服务器：192.168.1.200（提供 Web 服务，端口 80；SSH 服务，端口 22）\n需求：\n外网用户访问网关公网 IP 的 80 端口 → 转发到内网 192.168.1.200:80（Web 服务）\n外网用户访问网关公网 IP 的 2222 端口 → 转发到内网 192.168.1.200:22（SSH 服务，避免直接暴露 22 端口）","配置命令dnat-端口映射#配置命令（DNAT 端口映射）":"","配置命令snat-两种常用方式#配置命令（SNAT 两种常用方式）":"","重要操作保存-nat-规则避免重启失效#重要操作：保存 NAT 规则（避免重启失效）":"","需求#需求":"内网主机（192.168.1.100）通过网关服务器的公网 IP（203.0.113.10）访问外网，外网返回的数据通过网关转发回内网主机。","验证方法#验证方法":"内网主机（192.168.1.100）执行 ping 测试： ping 223.5.5.5 # ping 阿里云 DNS，测试外网连通性 网关服务器查看 nat 表规则： iptables -t nat -L POSTROUTING -n # 查看 SNAT 规则是否存在 外网服务器查看访问日志（如 Web 服务器），会显示访问源 IP 为网关公网 IP（203.0.113.10）。","验证方法-1#验证方法":"外网主机测试 Web 服务： curl http://203.0.113.10 # 应返回内网 192.168.1.200 的 Web 页面 外网主机测试 SSH 服务： ssh -p 2222 用户名@203.0.113.10 # 应连接到内网 192.168.1.200 的 SSH 网关查看 DNAT 规则和连接状态： iptables -t nat -L PREROUTING -n # 查看 DNAT 规则 netstat -an | grep :80 # 查看 80 端口连接（应显示内网服务器的连接）"},"title":"Iptables之nat配置"},"/docs/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/iptables%E5%9F%BA%E7%A1%80/":{"data":{"":"","centosrhel-系统#CentOS/RHEL 系统":"# 保存规则到配置文件 service iptables save # 或 iptables-save \u003e /etc/sysconfig/iptables # 设置开机自启（确保规则加载） systemctl enable iptables systemctl start iptables","ubuntudebian-系统#Ubuntu/Debian 系统":"默认无内置保存工具，需安装 iptables-persistent：\n# 安装工具 apt-get install -y iptables-persistent # 保存规则（保存后重启自动加载） netfilter-persistent save # 或手动保存到文件 iptables-save \u003e /etc/iptables/rules.v4","关键参数说明#关键参数说明":"参数 作用 -i eth0 指定网卡（公网网卡），仅匹配该网卡的流量 -p tcp 指定协议（TCP，80/443/22 均为 TCP 协议） --dport 指定 “目标端口”（即服务器开放的端口） -s 目标IP 指定 “源 IP”（仅允许该 IP 访问对应端口） -j ACCEPT 匹配后放行流量 -m state --state RELATED,ESTABLISHED 匹配 “已建立的连接” 或 “与已建立连接相关的流量”（如服务器访问外部后，外部返回的数据）","场景-1只允许指定-ip-访问服务器全局限制#场景 1：只允许指定 IP 访问服务器（全局限制）":"","场景-2公网仅开放-80443-端口22-端口仅指定-ip-访问内网互通#场景 2：公网仅开放 80/443 端口，22 端口仅指定 IP 访问，内网互通":"","场景-3补充说明内网互通的其他实现方式#场景 3：补充说明（内网互通的其他实现方式）":"若内网有多网段（如 192.168.1.0/24 和 192.168.2.0/24），需放行所有内网网段：\n# 放行 192.168.1.0/24 网段 iptables -A INPUT -s 192.168.1.0/24 -j ACCEPT # 放行 192.168.2.0/24 网段 iptables -A INPUT -s 192.168.2.0/24 -j ACCEPT 若需允许服务器主动访问内网其他主机（出站流量），确保 OUTPUT 链策略为 ACCEPT（默认通常如此）：\niptables -P OUTPUT ACCEPT","核心前提说明#核心前提说明":"以下命令均需 root 权限 执行（或前缀加 sudo）。\niptables 规则默认保存在内存中，重启后失效，配置完成后需执行 “保存命令”（见文末）。\n假设环境：\n公网网卡：eth0（可根据实际修改，如 ens33、eth1）\n内网网卡：eth1（内网网段示例：192.168.1.0/24）\n本地回环：lo（必须放行，否则影响本地服务通信）","注意事项#注意事项":"先放行关键 IP / 端口：配置 DROP 默认策略前，务必先放行 SSH 管理 IP（如 192.168.1.100），否则会被踢下线，无法远程恢复。\n网卡名称确认：通过 ip addr 命令查看实际网卡名称（如 ens33、eth0），避免配置错误。\n协议匹配：80/443/22 均为 TCP 协议，需指定 -p tcp；若需开放 UDP 端口（如 53 DNS），需改为 -p udp。\n云服务器安全组：若为云服务器（阿里云、腾讯云等），需同时在云厂商的 “安全组” 中开放对应端口，否则 iptables 配置生效但外部仍无法访问。","逻辑解释#逻辑解释":"-s：指定 “源 IP”（即访问方的 IP）。\nDROP：默认拒绝所有未匹配的入站流量，安全性最高（需确保已放行必要 IP，否则会失联）。\n若需添加多个 IP，重复执行 iptables -A INPUT -s 目标IP -j ACCEPT 即可。","配置命令#配置命令":"# 1. 清空现有规则（可选，首次配置建议执行） iptables -F iptables -X # 2. 放行本地回环（必须保留） iptables -A INPUT -i lo -j ACCEPT # 3. 放行已建立的连接（避免连接中断，如 SSH 登录后不被踢掉） iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT # 4. 允许指定 IP 访问（添加需要放行的 IP） iptables -A INPUT -s 192.168.1.100 -j ACCEPT # 内网管理机 iptables -A INPUT -s 203.0.113.20 -j ACCEPT # 外网固定 IP # 5. 拒绝所有其他入站请求（默认策略，放在最后） iptables -P INPUT DROP","配置命令-1#配置命令":"# 1. 清空现有规则（可选） iptables -F iptables -X # 2. 放行本地回环 iptables -A INPUT -i lo -j ACCEPT # 3. 放行已建立的连接（关键：允许服务器主动发起的连接返回数据） iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT # 4. 内网互通：允许内网网段（192.168.1.0/24）所有入站流量 iptables -A INPUT -i eth1 -s 192.168.1.0/24 -j ACCEPT # 按内网网卡限制 # 或（不限制网卡，仅按网段）：iptables -A INPUT -s 192.168.1.0/24 -j ACCEPT # 5. 22 端口（SSH）：仅允许指定 IP 访问 iptables -A INPUT -p tcp --dport 22 -s 192.168.1.100 -j ACCEPT # 内网管理机 iptables -A INPUT -p tcp --dport 22 -s 203.0.113.20 -j ACCEPT # 外网管理 IP # 6. 公网开放 80/443 端口（TCP 协议） iptables -A INPUT -i eth0 -p tcp --dport 80 -j ACCEPT # HTTP iptables -A INPUT -i eth0 -p tcp --dport 443 -j ACCEPT # HTTPS # 7. 默认策略：拒绝所有未匹配的入站流量 iptables -P INPUT DROP # （可选）放行出站流量（默认通常为 ACCEPT，若需限制可调整） iptables -P OUTPUT ACCEPT","重要操作保存-iptables-规则避免重启失效#重要操作：保存 iptables 规则（避免重启失效）":"","需求#需求":"仅允许 192.168.1.100（内网管理机）和 203.0.113.20（外网固定 IP）访问服务器所有开放端口，拒绝其他所有 IP。","需求拆解#需求拆解":"公网（eth0 网卡）：仅允许 80（HTTP）、443（HTTPS）端口访问，其他端口拒绝。\n22 端口（SSH）：仅允许 192.168.1.100（内网）和 203.0.113.20（外网管理 IP）访问。\n内网（192.168.1.0/24 网段）：所有主机可互通（任意端口、任意协议）。\n放行已建立的连接，避免通信中断。","验证与调试命令#验证与调试命令":"# 查看当前 iptables 规则（INPUT 链） iptables -L INPUT -n --line-numbers # 测试端口是否可访问（从外部主机执行） telnet 服务器IP 80 # 测试 80 端口 telnet 服务器IP 22 # 测试 22 端口（仅指定 IP 可通） # 清空所有规则（出错时紧急恢复） iptables -F iptables -X iptables -P INPUT ACCEPT # 临时放行所有入站，避免失联"},"title":"Iptables基础"},"/docs/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/tcpdump/":{"data":{"":"","1-抓取指定-ip-的数据包#1. 抓取指定 IP 的数据包":"tcpdump host 10.0.0.5","2-抓取指定网段的数据包#2. 抓取指定网段的数据包":"tcpdump net 192.168.1.0/24","3-抓取指定端口的数据包#3. 抓取指定端口的数据包":"tcpdump port 80","4-抓取多个端口的数据包#4. 抓取多个端口的数据包":"tcpdump port 80 or port 443 or port 8080","5-抓取指定-ip--端口的数据包#5. 抓取指定 IP + 端口的数据包":"tcpdump host 192.168.1.10 and port 8080","6-抓包内容保存到文件#6. 抓包内容保存到文件":"tcpdump host 192.168.1.10 and port 8080 -w /tmp/test.cap","7-docker容器内容抓包#7. docker容器内容抓包":"# 获取容器PID docker inspect --format \"{{ .State.Pid }}\" f6b48371b16d # 根据容器PID抓网卡eth0包 nsenter -n -t 25235 tcpdump -i eth0 -w /tmp/test.cap","基础说明#基础说明":"tcpdump 是 Linux 系统中强大的网络抓包工具，支持按 IP 地址、端口号、协议类型等条件过滤数据包，适用于网络故障排查、流量分析等场景。","常用辅助选项提升抓包效率#常用辅助选项（提升抓包效率）":"选项 作用 示例 -i 指定抓包网卡（如 eth0、ens33，any 表示所有网卡） tcpdump -i eth0 port 80 -w 将抓包结果保存到文件（后续可用 Wireshark 分析） tcpdump -i any host 192.168.1.10 -w capture.pcap -r 读取保存的抓包文件 tcpdump -r capture.pcap -n 不解析域名（显示 IP 地址，加快抓包速度） tcpdump -n port 443 -nn 不解析域名和端口名称（显示原始端口号） tcpdump -nn host 203.0.113.5 -v 显示详细抓包信息（-vv 更详细，-vvv 最详细） tcpdump -v tcp port 22 -c 指定抓包数量（抓够指定数量后自动退出） tcpdump -c 100 port 80（抓取 100 个包） -A 以 ASCII 格式显示数据包内容（方便查看 HTTP 等明文数据） tcpdump -A host 192.168.1.10 and port 80","示例#示例":""},"title":"Tcpdump"},"/docs/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/":{"data":{"":"","简介#简介":"发布一些自己编写的脚本工具。"},"title":"脚本工具"},"/docs/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/go/":{"data":{"":"golang编写实用工具"},"title":"Go"},"/docs/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/python/":{"data":{"":"python编写实用工具"},"title":"Python"},"/docs/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/python/%E5%86%85%E9%83%A8%E8%B5%84%E6%BA%90%E7%AB%99/":{"data":{"":"","html代码#html代码":"\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e内部资源站\u003c/title\u003e \u003clink rel=\"icon\" rel=\"stylesheet\" href=\"static/favicon.ico\"\u003e \u003clink rel=\"stylesheet\" href=\"static/index.css\"\u003e \u003cscript src=\"static/vue.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/index.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cdiv class=\"list\" v-for=\"(item, itemindex) in database\" :key=\"itemindex\"\u003e \u003ch3 style=\"padding-left: 10px;\"\u003e{{ item.indexname }}\u003c/h3\u003e \u003cdiv class=\"table\"\u003e \u003cel-card class=\"card\" shadow=\"hover\" v-for=\"app in item.appgroup\" :key=\"app.message\"\u003e \u003ctemplate v-if=\"app.lables\"\u003e \u003cimg v-bind:src=\"app.img\" class=\"image\"\u003e \u003cel-popover placement=\"right\" trigger=\"click\"\u003e \u003cel-table :data=\"app.env\" max-height=\"450\"\u003e \u003cel-table-column prop=\"urlname\" label=\"环境\"\u003e \u003ctemplate slot-scope=\"scope\"\u003e \u003cel-link :href=\"scope.row \u0026\u0026 scope.row.url\" target=\"_blank\"\u003e {{ scope.row.urlname }} \u003c/el-link\u003e \u003c/template\u003e \u003c/el-table-column\u003e \u003c/el-table\u003e \u003cel-button round slot=\"reference\" size=\"mini\"\u003e{{ app.urlname }}\u003c/el-button\u003e \u003c/el-popover\u003e \u003c/template\u003e \u003ctemplate v-else\u003e \u003cimg v-bind:src=\"app.img\" class=\"image\" v-on:click=\"urljump(app.url)\"\u003e \u003cdiv align=\"center\"\u003e\u003cspan\u003e{{ app.urlname }}\u003c/span\u003e\u003c/div\u003e \u003c/template\u003e \u003c/el-card\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el: '#app', data() { return { database: [] }; }, created() { fetch('/data') .then(response =\u003e response.json()) .then(data =\u003e { this.database = data; }) .catch(error =\u003e console.error('Error fetching data:', error)); }, methods: { urljump(url) { window.open(url) } } }); \u003c/script\u003e \u003cstyle\u003e .table { display: flex; flex-wrap: wrap; } .card { margin: 10px; box-sizing: border-box; width: 120px; } .el-card__body { display: flex; justify-content: center; align-items: center; flex-direction: column; padding: 10px !important; } .image { width: 70px; height: 70px; display: inline-box; border-radius: 10px; margin-bottom: 10px; } \u003c/style\u003e \u003c/body\u003e \u003c/html\u003e","python代码#python代码":"from flask import Flask, render_template, jsonify import json app = Flask(__name__) # 修改 Jinja2 默认语法 app.jinja_env.variable_start_string = '[[' app.jinja_env.variable_end_string = ']]' # 读取并返回 data.json 文件内容 @app.route('/data') def get_data(): try: with open('data-v2.json', 'r', encoding='utf-8') as file: data = json.load(file) return jsonify(data) # 返回 JSON 格式的数据 except FileNotFoundError: return jsonify({\"error\": \"File not found\"}), 404 except json.JSONDecodeError: return jsonify({\"error\": \"Error decoding JSON\"}), 500 # 渲染 index.html 页面并传递数据 @app.route('/') def index(): return render_template('index.html') if __name__ == '__main__': app.run(host=\"0.0.0.0\", port=8080)","目录结果#目录结果":"./ │ data-v2.json # 配置文件 │ main.py # python主函数 │ README.md │ ├───static │ │ favicon.ico │ │ index.css # Element ui │ │ index.js │ │ vue.js │ │ │ └───img │ 1panel.png # 展示的图片 │ aliyun.png │ archery.png │ arweb.png │ baota.png │ cdn.png │ └───templates index.html # 页面代码","简介#简介":"一个简单的资源管理站点, 使用python的flask工具开发, 引用Element样式, 方便管理和快速查找公司各种工具。","部署#部署":"","配置文件#配置文件":"根据配置文件数据格式展示图片内容,添加配置内容就是添加展示的项目列表\n[ { \"indexname\": \"研发工具\", \"appgroup\": [ { \"urlname\": \"jenkins\", \"img\": \"static/img/jenkins.png\", \"lables\": true, \"env\": [ { \"urlname\": \"内网\", \"url\": \"http://xxxxx\" }, { \"urlname\": \"生产\", \"url\": \"http://xxxxx\" } ] }, { \"urlname\": \"研发工具\", \"img\": \"static/img/it-tools.png\", \"url\": \"static/it-tools/\" } ] }, { \"indexname\": \"运维工具\", \"appgroup\": [ { \"urlname\": \"zabbix\", \"img\": \"static/img/zabbix.png\", \"url\": \"http://xxxxx\" } ] }, { \"indexname\": \"云平台\", \"appgroup\": [ { \"urlname\": \"腾讯云\", \"img\": \"static/img/tx.png\", \"url\": \"http://xxxxx\" } ] } ]"},"title":"内部资源站"},"/docs/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/shell/":{"data":{"":"shell编写实用脚本工具"},"title":"Shell"},"/docs/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/shell/%E7%AE%80%E6%98%93%E8%B7%B3%E6%9D%BF%E6%9C%BA/":{"data":{"":"","tssh界面配置#tssh界面配置":"更多配置查看github上tssh工具介绍\n# 支持中文 Language = Chinese # 每页显示30台服务器资源 PromptPageSize = 30","介绍#介绍":"使用tssh工具实现跳板机功能, 官网: https://github.com/trzsz/trzsz-ssh 展示效果","清理异常连接#清理异常连接":"跳板机如果非正常关闭,可能会存在大量异常连接需要释放\ntbj_PID=`ps aux|grep bash|grep ?|awk '{print $2}'` kill -9 $tbj_PID","部署#部署":"服务器192.168.1.1上, 安装tssh\ncurl -fsSL \"https://sh.wlnmp.com/wlnmp.sh\" | bash yum install tssh -y 创建登录用户\nuseradd test passwd test 创建服务器资源列表文件\n# 使用密码添加服务器资源 Host test1 HostName 192.168.1.2 User root Port 22 Password 123123 #!! GroupLabels test one # 使用密钥添加服务器资源 Host test2 HostName 192.168.1.3 User root Port 22 IdentityFile ~/.ssh/id_rsa #!! GroupLabels test two # 使用跳板机方式添加服务器资源 Host test4 HostName 192.168.1.4 User root Port 22 IdentityFile ~/.ssh/id_rsa ProxyJump test2 #!! GroupLabels test four 配置远程登录test开启跳板机界面\n# 远程登录test用户就直接进入界面 trap \"\" HUP INT QUIT TSTP while true do sleep 1 clear /usr/bin/tssh test -F /home/test/.ssh/config done 访问\nssh test@192.168.1.1"},"title":"简易跳板机"},"/docs/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/shell/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E8%84%9A%E6%9C%AC/":{"data":{"":"","简介#简介":"使用autossh工具实现, 功能:\n开放跳板机端口, 内网通过跳板机访问远程服务器 自动重连 支持多层跳板机","脚本#脚本":"安装\nyum -y install autossh 脚本在跳板机上运行, 主要通过跳板机端口实现转发\n#!/bin/bash # 用于配置ssh隧道转发 export AUTOSSH_POLL=60 export AUTOSSH_PORT=0 function start(){ # 测试1: 开放内网10.0.0.2的10001端口, 远程连接外网192.168.1.2的22端口 autossh -M 0 -o \"ExitOnForwardFailure yes\" -o \"ServerAliveInterval 30\" -o \"ServerAliveCountMax 3\" -fNL 0.0.0.0:10001:192.168.1.2:22 root@10.0.0.2 # 测试2: 开放内网10.0.0.2的10002端口, 远程连接外网192.168.1.3的22端口, 通过两层10.0.0.2, 172.32.0.2跳转到192.168.1.3 autossh -M 0 -o \"ExitOnForwardFailure yes\" -o \"ServerAliveInterval 30\" -o \"ServerAliveCountMax 3\" -fNL 0.0.0.0:10002:192.168.1.3:22 -J root@root@10.0.0.2 root@172.32.0.2 } function stop(){ for i in `ps aux|grep \"\\-NL\"|grep -v grep|awk '{print $2}'` do kill -9 $i done } function ls(){ for i in `ps aux|grep autossh|grep -v grep|grep -v ls|awk '{print $24}'|awk -F ':' '{print $2}'` do grep -B 1 $i /script/ssh-tunnel done } case $1 in \"start\") start ;; \"restart\") stop start ;; \"stop\") stop ;; \"ls\") ls ;; *) echo \"start|restart|stop|ls\" ;; esac"},"title":"Ssh端口转发脚本"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/":{"data":{"":"","简介#简介":"介绍一些运维需要掌握的服务部署和使用。"},"title":"运维服务"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/archery/":{"data":{"":"","简介#简介":"Archery是一款开源的数据库安全审计系统，主要用于监控和分析数据库操作行为，以增强数据库安全性并符合合规性要求。它通过捕获并分析SQL语句，帮助企业和组织了解、审查并控制对数据库的访问及操作，从而有效预防潜在的数据泄露风险。","部署#部署":"# 下载 wget https://github.com/hhyo/Archery/archive/refs/tags/v1.11.3.tar.gz # 解压 tar xf Archery-1.11.3.tar.gz # 启动 cd Archery-1.11.3/src/docker-compose/ docker-compose -f docker-compose.yml up -d # 表结构初始化 docker exec -ti archery /bin/bash cd /opt/archery source /opt/venv4archery/bin/activate python3 manage.py makemigrations sql python3 manage.py migrate # 数据初始化 python3 manage.py dbshell"},"title":"Archery"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/elk/":{"data":{"":"","logstash配置示例#logstash配置示例":"input { beats { port =\u003e 5044 } } filter { # 解析日志行，提取时间戳和其他字段 grok { match =\u003e { \"message\" =\u003e \"^\u003c(?\\d+)\u003e %{TIMESTAMP_ISO8601:log_timestamp} \\[%{LOGLEVEL:log_level_str}\\] %{IP:client_ip} #%{NUMBER:connection_id} \\[%{DATA:api_path}\\] \\[%{DATA:api_response}\\] %{NUMBER:response_time}ms (?{.*})$\" } tag_on_failure =\u003e [\"_grokparsefailure\"] } # 将日志时间戳设置为 @timestamp # 注意：日志格式是 \"2026-01-15 14:45:17\"，中间有空格 date { match =\u003e [\"log_timestamp\", \"yyyy-MM-dd HH:mm:ss\"] target =\u003e \"@timestamp\" timezone =\u003e \"Asia/Shanghai\" locale =\u003e \"zh_CN\" tag_on_failure =\u003e [\"_dateparsefailure\"] } # 如果日期解析失败，使用当前时间 if \"_dateparsefailure\" in [tags] { mutate { remove_tag =\u003e [\"_dateparsefailure\"] add_tag =\u003e [\"timestamp_fallback\"] } # 使用当前时间作为备选 date { match =\u003e [\"@timestamp\", \"ISO8601\"] timezone =\u003e \"Asia/Shanghai\" } } # 添加字段 mutate { add_field =\u003e { \"api_performance\" =\u003e \"%{response_time}\" \"status\" =\u003e \"%{response_time}\" } } # 清理不必要的字段 mutate { remove_field =\u003e [ \"[beat][hostname]\", \"[beat][name]\", \"[beat][version]\", \"[message]\" ] } } output { elasticsearch { hosts =\u003e [\"127.0.0.1:9200\"] index =\u003e \"%{index}-%{+YYYY-MM-dd}\" user =\u003e elastic password =\u003e aaabbbccc } }","启动#启动":"docker compose up -d","简介#简介":"ELK 是一套由 Elasticsearch、Logstash 和 Kibana 组成的开源工具，用于搜索、分析和可视化数据。","设置密码#设置密码":"修改配置elasticsearch.yml\nelasticsearch.yml# 1. 开启X-Pack安全认证（核心开关，7.7.0必须加） xpack.security.enabled: true # 2. 关闭SSL证书校验（7.7.0关键，否则启动失败，纯账号密码认证） xpack.security.transport.ssl.enabled: false # 3. 允许远程访问（保证Kibana能连接ES，已配置可忽略） network.host: 0.0.0.0 discovery.type: single-node 重启elasticsearch容器，并进入容器执行命令设置密码。\n# 执行初始化密码命令（7.7.0专属，固定命令） elasticsearch-setup-passwords interactive Initiating the setup of passwords for reserved users elastic,apm_system,kibana,logstash_system,beats_system. You will be prompted to enter passwords as the process progresses. Please confirm that you would like to continue [y/N] → 输入 y 回车 Enter password for [elastic]: → 输入你的密码（如Elk@7700），回车 Reenter password for [elastic]: → 重复输入密码，回车 Enter password for [apm_system]: → 输入密码，回车 ...（依次为kibana、logstash_system、beats_system设置密码，建议统一设为同一个） 设置kibana密码\nserver.name: kibana server.host: \"0\" elasticsearch.hosts: [ \"http://elasticsearch:9200\" ] xpack.monitoring.ui.container.elasticsearch.enabled: true i18n.locale: \"zh-CN\" # 配置ES的超级管理员账号（固定为elastic） elasticsearch.username: \"elastic\" # 配置该账号对应的密码（和你刚才为elastic设置的密码一致） elasticsearch.password: \"你设置的ES密码\" # 开启Kibana登录认证（7.7.0建议开启） xpack.security.enabled: true 设置logstash密码\ninput { # 来源beats beats { # 端口 port =\u003e \"5044\" } } output { elasticsearch { hosts =\u003e [\"http://elasticsearch:9200\"] # 按天生成索引 index =\u003e \"log-%{+YYYY.MM.dd}\" # 配置ES账号密码 user =\u003e \"elastic\" password =\u003e \"你设置的ES密码\" } stdout { codec =\u003e rubydebug } } 重启elk服务\ndocker compose restart","访问#访问":"curl http://127.0.0.1:5601","部署#部署":"创建es数据目录data和插件目录plugins\nmkdir data plugins chmod 777 data plugins 创建elasticsearch.yml\ncat \u003e elasticsearch.yml \u003c"},"title":"Elk"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/frp/":{"data":{"":"","下载#下载":"访问官方下载地址：https://github.com/fatedier/frp/releases 根据系统选择对应安装包（示例：Linux 服务器选 frp_0.65.0_linux_amd64.tar.gz 目录结构说明\n解压后核心文件如下（多余文件可删除，仅保留以下核心文件）：\n文件名 作用 适用端 frps 服务器端主程序 服务器 frps.toml 服务器端配置文件（v0.50+） 服务器 frpc 客户端主程序 内网设备 frpc.toml 客户端配置文件（v0.50+） 内网设备 frps.ini 旧版服务器配置文件（可选） 服务器（兼容旧版） frpc.ini 旧版客户端配置文件（可选） 客户端（兼容旧版）","启动客户端#启动客户端":"临时启动（测试使用）\n./frpc -c ./frpc.toml 后台启动（正式使用）\n创建服务文件\ncat \u003e /etc/systemd/system/frpc.service \u003c","启动服务器端#启动服务器端":"临时启动（测试用）\n./frps -c ./frps.toml 后台启动（生产环境）\n创建服务文件：\ncat \u003e /etc/systemd/system/frps.service \u003c","客户端frpc配置#客户端（frpc）配置":"frpc.toml# 服务端信息 serverAddr = \"公网ip，服务端地址\" serverPort = 20001 # 连接协议 transport.protocol = \"tcp\" # 认证方式 auth.method = \"token\" auth.token = \"aabbcc112233\" # 代理配置 [[proxies]] name = \"test_1\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 22 remotePort = 20002 [[proxies]] name = \"test_2\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 5001 remotePort = 20003","服务器端frps配置#服务器端（frps）配置":"frps.toml# 绑定监听地址（默认 `0.0.0.0` 代表监听所有 IP） bindAddr = \"0.0.0.0\" bindPort = 20001 # Web 控制台（Dashboard）配置 webServer.addr = \"0.0.0.0\" webServer.port = 7500 webServer.user = \"moxi\" webServer.password = \"abc123\" # 认证方式（防止未经授权的客户端连接） auth.method = \"token\" auth.token = \"aabbcc112233\" # 端口限制 allowPorts = [ { start = 20000, end = 20010 } ]"},"title":"Frp"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/gitlab/":{"data":{"":"","启动#启动":"docker compose up -d","简介#简介":"GitLab 是一个基于 Git 的开源版本控制和协作平台，旨在支持软件开发的整个生命周期，包括源代码管理、持续集成/持续部署（CI/CD）、项目管理和监控等功能。它提供了一系列工具，帮助团队高效地协作和交付软件。","访问#访问":"curl http://192.168.40.10:8999 ​","部署#部署":"docker-compose.yamlcat \u003e docker-compose.yaml \u003c"},"title":"Gitlab"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/grafana/":{"data":{"启动#启动":"docker compose up -d","简介#简介":"简介Grafana 是一个开源的可视化和分析平台，主要用于监控和数据展示。它支持多种数据源，允许用户通过动态仪表板来实时查看和分析数据，广泛应用于 IT 监控、业务分析和运营分析等领域。","部署#部署":"cat \u003e docker-compose.yaml \u003c"},"title":"Grafana"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/harbor/":{"data":{"":"","简介#简介":"Harbor 是一个开源的云原生注册中心，用于管理和分发容器镜像。它提供了一个安全、高效且功能丰富的平台，旨在为企业级应用提供镜像存储和管理服务。","访问#访问":"默认账号：admin 密码：Harbor12345\ncurl http://192.168.40.10","部署#部署":"安装包已绑定到博客上方\n# 下载 wget https://github.com/goharbor/harbor/releases/download/v2.10.3/harbor-online-installer-v2.10.3.tgz # 解压 tar xf harbor-online-installer-v2.10.3.tgz cd harbor # 复制配置模板为配置文件 cp harbor.yml.tmpl harbor.yml # 修改配置，默认端口为80，如果需要修改端口，请自行修改harbor.yml配置 ## 改为本机ip sed -i 's/hostname: reg.mydomain.com/hostname: 192.168.40.10/g' harbor.yml ## 关闭https sed -i 's/https:/#https:/g' harbor.yml sed -i 's/port: 443/#port: 443/g' harbor.yml sed -i 's#certificate: /your/certificate/path#\\#certificate: /your/certificate/path#g' harbor.yml sed -i 's#private_key: /your/private/key/path#\\#private_key: /your/private/key/path#g' harbor.yml # 安装，自动生成docker-compose.yaml文件，并启动 ./install.sh"},"title":"Harbor"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/jenkins/":{"data":{"":"","启动#启动":"docker compose up -d # 访问 curl http://127.0.0.1:8080","简介#简介":"Jenkins 是一个开源的自动化服务器，广泛用于持续集成（CI）和持续交付（CD）过程。它能够帮助开发团队自动化构建、测试和部署软件，从而提高开发效率和软件质量。","部署#部署":"cat \u003e docker-compose.yaml \u003c","配置#配置":"查看日志，获取32位字符串（类似）：a371e758bc1f44f4960a5f53358f1070 浏览器访问jenkins，配置时，需要该字符串\n# 查看日志 docker logs jenkins"},"title":"Jenkins"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/mindoc/":{"data":{"":"","启动#启动":"docker compose up -d","简介#简介":"Mindoc 是一个开源的在线文档管理和协作平台，旨在简化文档的创建、管理和共享。它通常用于团队内部知识管理、项目文档编写和技术文档存储。","访问#访问":"默认账号：admin 密码：123456\ncurl http://127.0.0.1:8181","部署#部署":"cat \u003e docker-compose.yaml \u003c"},"title":"Mindoc"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/nacos/":{"data":{"":"","启动#启动":"docker compose up -d","简介#简介":"Nacos（Naming and Configuration Service）是一个开源的动态服务发现、配置管理和服务管理平台，旨在帮助微服务架构中的服务治理。它由阿里巴巴开发，广泛应用于云原生应用和微服务环境中。","部署#部署":"docker-compose.yaml\ncat \u003e docker-compose.yaml \u003c"},"title":"Nacos"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/nextcloud/":{"data":{"":"","启动#启动":"docker compose up -d","简介#简介":"Nextcloud 是一个开源的云存储和文件共享平台，旨在为用户提供安全、私有的文件管理和协作解决方案。它可以自托管在用户自己的服务器上，确保数据的隐私和安全性。","访问#访问":"浏览器直接输入部署的主机ip加9091即可\ncurl http://127.0.0.1:9091","部署#部署":"cat \u003e docker-compose.yaml \u003c"},"title":"Nextcloud"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/nexus/":{"data":{"":"","启动#启动":"docker compose up -d","简介#简介":"Nexus Repository Manager 是一个强大的开源仓库管理工具，主要用于存储和管理软件包、构件和依赖项。它支持多种格式，包括 Maven、npm、Docker、NuGet 等，帮助开发团队更有效地管理其开发和发布流程。","访问#访问":"登录时会提示密码存放位置，第一次登录需要改密码\ncurl http://127.0.0.1:8081","部署#部署":"docker-compose.yamlservices: nexus: image: sonatype/nexus3:3.67.1-java11 # 镜像版本 container_name: nexus # 容器名称 restart: always # 自动重启 environment: - TZ=Asia/Shanghai # 设置时区 ports: - \"8081:8081\" # 端口映射 volumes: # 持久化数据 - nexus_data:/nexus-data deploy: resources: limits: cpus: \"1\" # 限制 CPU 核心数，nexus建议4核cpu memory: \"2G\" # 限制内存大小 volumes: nexus_data:"},"title":"Nexus"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/nginx/":{"data":{"":"","80与443同时使用#80与443同时使用":"server { listen 80; listen 443 ssl; server_name test.hxq.cn; # 证书配置 ssl_certificate ssl/test.hxq.cn.crt; ssl_certificate_key ssl/test.hxq.cn.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # 压缩配置 gzip on; gzip_disable \"msie6\"; gzip_vary on; gzip_proxied any; gzip_comp_level 6; gzip_buffers 16 8k; gzip_http_version 1.1; gzip_min_length 256; gzip_types application/octet-stream application/atom+xml application/geo+json application/javascript application/x-javascript application/json application/ld+json application/manifest+json application/rdf+xml application/rss+xml application/xhtml+xml application/xml font/eot font/otf font/ttf image/svg+xml text/css text/javascript text/plain text/xml; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_pass http://192.168.1.2:8080; } }","80强制跳转443#80强制跳转443":"# 第一个server块：专门处理80端口请求，强制跳转至443 HTTPS server { listen 80; server_name test.hxq.cn; # 核心跳转配置：301永久重定向（SEO友好，浏览器会缓存跳转规则） # $scheme 自动识别协议，$host 自动获取当前server_name，$request_uri 保留完整请求路径和参数 return 301 https://$host$request_uri; }","ailis和root#ailis和root":"对比项 root 指令 alias 指令 路径拼接规则 最终路径 = root 路径 + 完整请求 URI 最终路径 = alias 路径 + （请求 URI - location 匹配部分） 生效层级 http、server、location 均可 仅 location 块中有效 对 location 匹配要求 无特殊要求，支持 =、、^ 等所有匹配模式\t匹配非正则 location（=、^~、普通前缀）时最优，正则 location 中不推荐使用（可能失效） 目录末尾 无强制要求，有无 / 对拼接结果影响较小 建议添加 /，否则多级路径拼接可能出现错误 适用场景 匹配整个网站根目录、常规静态文件目录（URI 与目录结构一致） 匹配局部路径、需要替换 URI 前缀的场景（URI 与目录结构不一致）","docker部署#docker部署":"初始化操作\n# 创建目录 mkdir -p ./nginx/html ./nginx/conf.d # 拷贝nginx配置文件 docker run --rm -it nginx:latest cat /etc/nginx/conf.d/default.conf \u003e ./nginx/conf.d/default.conf docker run --rm -it nginx:latest cat /etc/nginx/nginx.conf \u003e ./nginx/nginx.conf docker run --rm -it nginx:latest cat /usr/share/nginx/html/index.html \u003e ./nginx/html/index.html 创建yaml\ndocker-compose.yamlversion: '3.8' services: nginx: image: nginx:latest container_name: nginx # 容器名称 restart: always # 自动重启 environment: - TZ=Asia/Shanghai # 设置时区 ports: - \"80:80\" # 映射端口 deploy: resources: limits: cpus: \"0.5\" # 限制 CPU 核心数 memory: \"512M\" # 限制内存大小 volumes: - ./nginx/html:/usr/share/nginx/html # 数据持久化 - ./nginx/conf.d:/etc/nginx/conf.d # 配置持久化 - ./nginx/nginx.conf:/etc/nginx/nginx.conf # 配置持久化 启动\ndocker compose up -d ​","url下划线支持#url下划线支持":"# 开启请求头中的下划线支持（默认off，会忽略含下划线的请求头） # 补充：Nginx默认支持URL路径中的下划线，此配置主要解决\"请求头下划线\"和\"反向代理传递下划线参数\"问题 underscores_in_headers on;","yum部署#yum部署":"执行\nyum install -y nginx nginx-all-modules 修改，添加最大文件打开数配置\n/usr/lib/systemd/system/nginx.serviceLimitNOFILE=65000 启动\nsystemctl start nginx # 开机自启 systemctl enable nginx # 重新加载systemctl配置 systemctl daemon-reload","指定host转发#指定host转发":"# 两种方案可选，根据后端服务需求选择其一 # 方案1：传递原始客户端请求的Host（即test.hxq.cn，推荐，保持请求一致性） # 方案2：传递后端服务需要的自定义Host（例如后端要求Host为backend.hxq.cn，按需修改） # proxy_set_header Host backend.hxq.cn; proxy_set_header Host $host;","斜杠说明#斜杠说明":"proxy_pass 末尾是否加 /，核心影响Nginx 向后端转发请求时的 URI 拼接规则，分为两种核心场景：\nproxy_pass 末尾不加 /：Nginx 会保留客户端请求的「完整 URI」（包含 location 匹配的前缀部分），拼接在后端地址后。 proxy_pass 末尾加 /：Nginx 会剔除客户端请求 URI 中与 location 匹配的前缀部分，仅将剩余 URI 拼接在后端地址后。","日志格式配置#日志格式配置":"# 定义名为 main 的Nginx访问日志格式 # 格式规范：key:\"value\" 形式包裹字段，避免特殊字符破坏日志结构；字段按「请求信息→状态信息→业务信息→客户端信息」归类 log_format main '$remote_addr - $remote_user [$time_local] ' # 基础连接信息 # $remote_addr: 客户端IP地址（Nginx直接对接的客户端，无前端代理时即为真实IP） # $remote_user: HTTP基本认证用户名（未配置auth_basic时显示为\"-\"） # $time_local: 服务器本地时间（格式：dd/MMM/yyyy:HH:mm:ss +时区） 'requesthost:\"$http_host\"; ' # 客户端请求的主机名（域名/IP:端口，如 test.hxq.cn:8080） '\"$request\" ' # 完整请求行（格式：请求方法 请求URI HTTP协议版本，如 GET /test HTTP/1.1） 'requesttime:\"$request_time\"; ' # 整个请求的处理耗时（单位：秒，精确到毫秒，如 0.023） '$status $body_bytes_sent ' # 响应状态信息 # $status: Nginx返回给客户端的HTTP状态码（如 200成功、502网关错误） # $body_bytes_sent: Nginx发送给客户端的响应体字节数（不含响应头） '\"$http_referer\" ' # 请求来源页面（Referer请求头，直接访问时显示为\"-\"） 'request_body:\"$request_body\" ' # 客户端请求体内容（仅POST/PUT等方法有值，大体积请求体可能为空） 'content_type:\"$http_content_type\" ' # 请求体的媒体类型（Content-Type请求头，无请求体时显示为\"-\"） 'request_length:\"$request_length\" ' # 客户端请求的总字节数（包含请求头+请求体） 'upstream_response_time:\"$upstream_response_time\" ' # 反向代理专用：Nginx等待后端服务响应的耗时（单位：秒，多个后端用逗号分隔） 'upstream_addr:\"$upstream_addr\" ' # 反向代理专用：实际转发的后端服务地址（IP:端口，多个后端用逗号分隔） '\"$http_user_agent\" ' # 客户端用户代理标识（浏览器/爬虫类型，如 Chrome/143.0.0.0） 'x_forwarded_for:\"$http_x_forwarded_for\" ' # 客户端真实IP链路（X-Forwarded-For请求头，无前端代理时显示为\"-\"） 'access_control_request_headers:\"$http_access_control_request_headers\"'; # 跨域预检专用：前端声明的自定义请求头（非OPTIONS请求时显示为\"-\"）","真实ip转发配置#真实ip转发配置":"# 传递客户端直接IP（若Nginx前无反向代理/CDN，此值即为真实客户端IP） proxy_set_header X-Real-IP $remote_addr; # 传递IP链路（包含客户端真实IP+各级代理IP） proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 传递客户端原始请求协议（http/https） proxy_set_header X-Forwarded-Proto $scheme; # 传递客户端原始请求主机名 proxy_set_header X-Forwarded-Host $host;","跨域配置#跨域配置":"# 允许请求来源（动态适配前端域名，比硬编码*更安全） add_header Access-Control-Allow-Origin $http_origin; # 允许的HTTP请求方法 add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS,PATCH; # 允许的请求头 add_header Access-Control-Allow-Headers Origin,Content-Type,Accept,Authorization,X-Real-IP,X-Forwarded-For; # 允许携带Cookie/认证信息（配合前端withCredentials使用） add_header Access-Control-Allow-Credentials true; # 预检请求（OPTIONS）缓存时间（1天），减少预检请求次数 add_header Access-Control-Max-Age 86400; # 处理预检请求（OPTIONS）：直接返回204，无需转发到后端服务 if ($request_method = OPTIONS) { return 204; }","配置示例#配置示例":"","长连接配置#长连接配置":"# 基础：启用HTTP/1.1协议（WebSocket代理的前提） proxy_http_version 1.1; # 核心1：传递客户端的Upgrade请求头给后端服务 proxy_set_header Upgrade $http_upgrade; # 核心2：强制设置Connection请求头为\"upgrade\"，触发协议升级 proxy_set_header Connection \"upgrade\";"},"title":"Nginx"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/nginxwebui/":{"data":{"":"","简介#简介 ":"Nginx Web UI 是一个用于管理和配置 Nginx 服务器的用户界面工具。它提供直观的图形界面，使得用户能够更方便地设置和维护 Nginx 配置，而无需直接编辑配置文件。","部署#部署":"docker-compose.yamlversion: '3.8' services: nginxwebui: image: cym1102/nginxwebui:4.2.4 container_name: nginxwebui # 容器名称 restart: always # 自动重启 environment: BOOT_OPTIONS: \"--server.port=8081\" # 定义服务访问端口 privileged: true # 特权模式 network_mode: \"host\" # host网络模式 deploy: resources: limits: cpus: \"0.5\" # 限制 CPU 核心数 memory: \"512M\" # 限制内存大小 volumes: - ./nginxWebUI:/home/nginxWebUI # 数据持久化 ## 启动\ndocker compose up -d ​"},"title":"Nginxwebui"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/openvpn/":{"data":{"":"","客户端#客户端":"复制创建用户生成的 test.ovpn 到 客户端机器上的 /etc/openvpn/client/\n安装openvpn包\nyum -y install epel-release yum -y install openvpn 启动客户端\nopenvpn --daemon --cd /etc/openvpn/client/ --config test.ovpn --log-append /var/log/test-vpn.log","服务端操作#服务端操作":"初始化, 注意修改公网ip地址\ndocker run -v ./openvpn:/etc/openvpn --rm kylemanna/openvpn ovpn_genconfig -u udp://公网地址 docker run -v ./openvpn:/etc/openvpn --rm -it kylemanna/openvpn ovpn_initpki 启动\ndocker run -v ./openvpn:/etc/openvpn -d -p 1194:1194/udp --cap-add=NET_ADMIN kylemanna/openvpn 修改，需重启服务生效\n./openvpn/openvpn.conf# 客户端连接分配的ip池 server 192.168.254.0 255.255.255.0 verb 3 key /etc/openvpn/pki/private/123.60.11.34.key ca /etc/openvpn/pki/ca.crt cert /etc/openvpn/pki/issued/123.60.11.34.crt dh /etc/openvpn/pki/dh.pem tls-auth /etc/openvpn/pki/ta.key key-direction 0 keepalive 10 60 persist-key persist-tun proto udp # Rely on Docker to do port mapping, internally always 1194 port 1194 dev tun0 status /tmp/openvpn-status.log user nobody group nogroup comp-lzo no ### Route Configurations Below route 192.168.253.0 255.255.255.0 # 客户端可以连接的服务端网段 ### Push Configurations Below push \"route 192.168.0.0 255.255.255.0\" push \"comp-lzo no\" 创建test用户\ndocker run -v ./openvpn:/etc/openvpn --rm -it kylemanna/openvpn easyrsa build-client-full test nopass docker run -v ./openvpn:/etc/openvpn --rm kylemanna/openvpn ovpn_getclient test \u003e /tmp/test.ovpn 删除用户\ndocker run -v openvpn-data:/etc/openvpn --rm -it kylemanna/openvpn easyrsa revoke test docker run -v openvpn-data:/etc/openvpn --rm -it kylemanna/openvpn easyrsa gen-crl","简介#简介":"OpenVPN 是一个开源的虚拟私人网络（VPN）解决方案，广泛用于安全地连接远程用户和分支机构到企业网络。它通过安全的隧道加密技术，确保数据在不安全的网络上进行安全传输。","部署#部署":""},"title":"Openvpn"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/promethous/":{"data":{"":"","启动#启动":"docker compose up -d","部署#部署":"docker-compose.yaml\nversion: '3.8' services: prometheus: image: prom/prometheus container_name: prometheus restart: always environment: - TZ=Asia/Shanghai # 设置时区 ports: - \"9090:9090\" volumes: - prom_conf:/etc/prometheus - prom_data:/prometheus command: - '--config.file=/etc/prometheus/prometheus.yml' - '--storage.tsdb.path=/prometheus' - '--web.enable-admin-api' # 控制对admin HTTP API的访问，其中包括删除时间序列等功能 - '--web.enable-lifecycle' # 支持热更新，直接执行localhost:9090/-/reload立即生效 deploy: resources: limits: cpus: \"1\" # 限制 CPU 核心数 memory: \"2G\" # 限制内存大小 alertmanager: image: prom/alertmanager container_name: alertmanager restart: always environment: - TZ=Asia/Shanghai # 设置时区 ports: - \"9093:9093\" volumes: - alert_conf:/etc/alertmanager deploy: resources: limits: cpus: \"1\" # 限制 CPU 核心数 memory: \"1G\" # 限制内存大小 volumes: prom_data: prom_conf: alert_conf:"},"title":"Promethous"},"/docs/%E8%BF%90%E7%BB%B4%E6%9C%8D%E5%8A%A1/zabbix/":{"data":{"":"","启动#启动":"docker compose up -d","简介#简介":"Zabbix 是一个开源的监控解决方案，主要用于监控 IT 基础设施的性能和可用性。它能够监控多种资源，包括服务器、网络设备、虚拟机和云服务等。以下是 Zabbix 的一些关键特点和功能：","访问#访问":"curl https://127.0.0.1:80","部署#部署":"version: \"3.5\" services: mysql-server: image: mysql:5.7 container_name: mysql-server restart: unless-stopped command: --character-set-server=utf8 --collation-server=utf8_bin --sql_mode=STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION --lower_case_table_names=1 environment: - MYSQL_DATABASE=zabbix - MYSQL_USER=zabbix - MYSQL_PASSWORD=zabbix - MYSQL_ROOT_PASSWORD=zabbix ports: - 3306:3306 volumes: - /etc/localtime:/etc/localtime:ro - /data/zabbix-mysql:/var/lib/mysql:rw zabbix-server-mysql: image: zabbix/zabbix-server-mysql:alpine-5.0-latest container_name: zabbix-server-mysql restart: unless-stopped environment: - DB_SERVER_HOST=mysql-server - MYSQL_USER=zabbix - MYSQL_PASSWORD=zabbix - MYSQL_DATABASE=zabbix - MYSQL_ROOT_PASSWORD=zabbix ports: - 10051:10051 links: - mysql-server depends_on: - mysql-server volumes: - /etc/localtime:/etc/localtime:ro - /etc/timezone:/etc/timezone:ro - /data/zabbix:/etc/zabbix/ zabbix-web: image: zabbix/zabbix-web-nginx-mysql:alpine-5.0-latest container_name: zabbix-web-nginx-mysql restart: unless-stopped environment: - DB_SERVER_HOST=mysql-server - MYSQL_USER=zabbix - MYSQL_PASSWORD=zabbix - MYSQL_DATABASE=zabbix - MYSQL_ROOT_PASSWORD=zabbix - PHP_TZ=Asia/Shanghai ports: - 80:8080 volumes: - /etc/localtime:/etc/localtime:ro - /etc/timezone:/etc/timezone:ro - /data/zabbix-web:/usr/share/zabbix/assets/fonts links: - mysql-server - zabbix-server-mysql depends_on: - mysql-server - zabbix-server-mysql"},"title":"Zabbix"},"/docs/k8s/":{"data":{"":"","简介#简介":"介绍一些k8s使用技术和经验。"},"title":"k8s"},"/docs/k8s/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/":{"data":{"":"","安装#安装":"安装k8s 1.19.9版本脚本\nbash -c \"$(curl -SsL https://docs.hxq1990.top/scripts/install.sh)\"","组件介绍#组件介绍":"K8s 采用主从（Master-Node）架构。\n控制平面（Control Plane / Master Node） 这是集群的“大脑”，负责全局决策和协调。 API Server： 集群的前端入口，所有交互（命令行、UI、API调用）都通过它。它是唯一与 etcd 通信的组件。\netcd： 一个高可用的键值存储数据库，保存了整个集群的所有配置数据和状态信息，是集群的“唯一信源”。\nScheduler： 负责调度，决定将新创建的 Pod 放到哪个 Node 上运行。\nController Manager： 运行着各种控制器，这些控制器不断循环，确保集群的实际状态与用户声明的期望状态一致（例如，确保副本数量正确）。\n数据平面 / 工作节点（Worker Nodes） 这是运行容器化应用的实际“劳动力”。 Kubelet： 节点上的“代理”，负责与 API Server 通信，管理本节点上 Pod 的生命周期（创建、启动、停止容器）。\nContainer Runtime： 负责运行容器的软件，如 Docker、containerd、CRI-O。\nKube-Proxy： 维护节点上的网络规则，实现 Pod 间的网络通信和负载均衡。\nPod Pod 是 Kubernetes 中最小的部署和管理单元。一个 Pod 可以包含一个或多个紧密关联的容器（通常是一个）。这些容器共享网络命名空间、IP 地址和存储卷，就像运行在同一台逻辑主机上。"},"title":"基本概念"},"/docs/k8s/configmap%E5%9F%BA%E7%A1%80/":{"data":{"":"","作为命令行参数通过环境变量中转#作为命令行参数（通过环境变量中转）":"apiVersion: v1 kind: Pod metadata: name: pod-command-config-demo spec: containers: - name: demo-container image: busybox # 命令行参数引用环境变量（环境变量来自 ConfigMap） command: [\"/bin/sh\", \"-c\", \"echo '当前环境：$(APP_ENV)，版本：$(APP_VERSION)' \u0026\u0026 sleep 3600\"] env: - name: APP_ENV valueFrom: configMapKeyRef: name: app-yaml-config key: app.env - name: APP_VERSION valueFrom: configMapKeyRef: name: app-yaml-config key: app.version restartPolicy: Never","作为环境变量#作为环境变量":"apiVersion: v1 kind: Pod metadata: name: pod-env-config-demo spec: containers: - name: demo-container image: busybox command: [\"/bin/sh\", \"-c\", \"env | grep APP_ \u0026\u0026 sleep 3600\"] # 打印环境变量并休眠 env: # 单个环境变量：直接引用 ConfigMap 的某个键值对 - name: APP_ENV # 容器内的环境变量名 valueFrom: configMapKeyRef: name: app-yaml-config # 引用的 ConfigMap 名称 key: app.env # 引用的 ConfigMap 中的键 - name: APP_VERSION # 另一个环境变量 valueFrom: configMapKeyRef: name: app-yaml-config key: app.version # （可选）批量注入环境变量：将 ConfigMap 所有键值对作为环境变量注入 envFrom: - configMapRef: name: app-simple-config # 引用的 ConfigMap 名称（方式 1 创建的） restartPolicy: Never","挂载为文件#挂载为文件":"apiVersion: v1 kind: Pod metadata: name: pod-volume-file-config-demo spec: containers: - name: demo-container image: busybox command: [\"/bin/sh\", \"-c\", \"cat /app/db.properties \u0026\u0026 sleep 3600\"] volumeMounts: - name: config-volume # 与 volumes 中定义的卷名对应 mountPath: /app/db.properties # 容器内的单个文件路径 subPath: db.properties # 引用 ConfigMap 中的某个键（对应生成的文件名） volumes: - name: config-volume configMap: name: app-yaml-config # 引用的 ConfigMap 名称 items: # 可选：筛选需要挂载的键（不写则挂载所有） - key: db.properties path: db.properties # 卷内的文件路径（与 subPath 对应） restartPolicy: Never","挂载为目录支持热更新#挂载为目录(支持热更新)":"apiVersion: v1 kind: Pod metadata: name: pod-volume-dir-config-demo spec: containers: - name: demo-container image: busybox command: [\"/bin/sh\", \"-c\", \"ls /app/config \u0026\u0026 cat /app/config/app.conf \u0026\u0026 sleep 3600\"] volumeMounts: - name: config-volume # 与 volumes 中定义的卷名对应 mountPath: /app/config # 容器内的挂载目录（该目录下原有文件会被覆盖） volumes: - name: config-volume # 定义卷名称 configMap: name: app-yaml-config # 引用的 ConfigMap 名称 restartPolicy: Never"},"title":"Configmap基础"},"/docs/k8s/kubectl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/":{"data":{"":"","yaml格式查看pod文件#yaml格式查看pod文件":"kubectl get pod -o yaml","修改配置#修改配置":"# 编辑pod（不推荐直接编辑pod） kubectl edit pod # 编辑deployment（推荐方式） kubectl edit deployment # 编辑configmap kubectl edit configmap # 编辑secret kubectl edit secret","拷贝pod中文件#拷贝pod中文件":"# 拷贝单个文件 kubectl cp /:/path/to/file ./local_file # 指定容器拷贝 kubectl cp /:/app/logs/app.log ./app.log -c # 拷贝整个目录 kubectl cp /:/var/log/ ./pod_logs/ # 简写（默认命名空间） kubectl cp :/etc/config/conf.yaml ./conf.yaml # 拷贝文件到pod kubectl cp ./config.yaml /:/etc/app/config.yaml # 拷贝目录到pod kubectl cp ./config/ /:/etc/app/ # 带权限保留拷贝 kubectl cp --preserve ./script.sh :/tmp/script.sh","查看pod日志#查看pod日志":"# 查看当前pod日志 kubectl logs -n # 查看异常重启前日志 kubectl logs -p -n # 查看最后10条日志 kubectl logs --tail=10 -p -n","查看pod详细信息#查看pod详细信息":"kubectl describe pod -n","登录pod#登录pod":"# 进入pod的默认容器 kubectl exec -it -- /bin/bash # 进入pod的指定容器 kubectl exec -it -c -- /bin/sh # 如果容器没有bash，使用sh kubectl exec -it -- /bin/sh # 执行单条命令 kubectl exec -- ls -la /app"},"title":"Kubectl常用命令"},"/docs/k8s/log-pilot%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86/":{"data":{"":"","使用示例#使用示例":"--- apiVersion: apps/v1 kind: Deployment metadata: name: nginx namespace: default spec: progressDeadlineSeconds: 600 replicas: 1 revisionHistoryLimit: 10 selector: matchLabels: k8s.kuboard.cn/layer: '' k8s.kuboard.cn/name: nginx strategy: rollingUpdate: maxSurge: 1 maxUnavailable: 0 type: RollingUpdate template: metadata: creationTimestamp: null labels: k8s.kuboard.cn/layer: '' k8s.kuboard.cn/name: nginx spec: containers: - env: # 采集pod内日志文件 - name: aliyun_logs_yace-nginx-error value: /opt/log/*.log # 采集k8s控制台输出日志 - name: aliyun_logs_yace-nginx-access value: stdout image: 'nginx:1.29.1-alpine' imagePullPolicy: IfNotPresent lifecycle: {} name: nginx resources: limits: cpu: '1' memory: 1Gi requests: cpu: 100m memory: 100Mi terminationMessagePath: /dev/termination-log terminationMessagePolicy: File # 采集pod内日志文件需要创建目录挂载 volumeMounts: - mountPath: /opt/log name: locallog dnsConfig: {} dnsPolicy: ClusterFirst nodeSelector: beta.kubernetes.io/arch: amd64 restartPolicy: Always schedulerName: default-scheduler securityContext: seLinuxOptions: {} terminationGracePeriodSeconds: 30 # 采集pod内日志文件需要创建目录挂载 volumes: - emptyDir: {} name: locallog","配置#配置":"apiVersion: apps/v1 kind: DaemonSet metadata: name: log-pilot labels: k8s-app: log-pilot namespace: default spec: selector: matchLabels: k8s-app: log-pilot updateStrategy: type: RollingUpdate template: metadata: labels: k8s-app: log-pilot spec: tolerations: - key: node-role.kubernetes.io/master effect: NoSchedule containers: - name: log-pilot image: registry.cn-hangzhou.aliyuncs.com/acs/log-pilot:0.9.5-filebeat env: - name: \"LOGGING_OUTPUT\" value: \"logstash\" - name: \"LOGSTASH_HOST\" value: \"192.168.1.2\" - name: \"LOGSTASH_PORT\" value: \"5044\" - name: \"LOGSTASH_LOADBALANCE\" value: \"true\" - name: \"NODE_NAME\" valueFrom: fieldRef: fieldPath: spec.nodeName resources: limits: cpu: 1000m memory: 1000Mi requests: cpu: 250m memory: 128Mi volumeMounts: - name: sock mountPath: /var/run/docker.sock - name: logs mountPath: /var/log/filebeat - name: state mountPath: /var/lib/filebeat - name: root mountPath: /host readOnly: true - name: localtime mountPath: /etc/localtime securityContext: capabilities: add: - SYS_ADMIN terminationGracePeriodSeconds: 30 volumes: - name: sock hostPath: path: /var/run/docker.sock - name: logs hostPath: path: /var/log/filebeat - name: state hostPath: path: /var/lib/filebeat - name: root hostPath: path: / - name: localtime hostPath: path: /etc/localtime"},"title":"Log Pilot日志采集"},"/docs/linux/":{"data":{"":"包含各个linux系统的配置"},"title":"linux"},"/docs/linux/%E5%9B%BE%E6%A0%87/":{"data":{"":"","人员与团队#人员与团队":"角色\n👤 用户 👥 用户组 👨‍💻 程序员 👩‍💻 女程序员 🧑‍💻 技术人员 🛡️ 安全 🔐 管理员 通信\n💬 对话 🗨️ 发言 👂 监听 📢 广播 📣 扩音器 📤 发送 📥 接收","实用工具图标#实用工具图标":"工具\n🔧 工具 🔨 锤子 ⚒️ 锤子和镐 🛠️ 扳手和锤子 🔩 螺母和螺栓 ⚙️ 齿轮 🗜️ 夹钳 搜索与查找\n🔍 放大镜 🔎 放大镜(右) 🕵️ 侦探 📡 雷达 📍 定位 🎯 靶心","文件与文档#文件与文档":"文件类型\n📁 文件夹 📂 打开文件夹 📄 文档 📃 页面 📑 书签 📊 图表 📈 增长图 📉 下降图 📋 剪贴板 文档操作\n✏️ 编辑 📝 备忘录 📌 图钉 📍 圆针 📎 附件 🖊️ 钢笔 🖋️ 钢笔尖 ✒️ 钢笔","时间相关图标#时间相关图标":"时钟\n🕐 🕑 🕒 🕓 🕔 🕕 🕖 🕗 🕘 🕙 🕚 🕛 🕜 🕝 🕞 🕟 🕠 🕡 🕢 🕣 🕤 🕥 🕦 🕧 🕐 时间 日历时间\n📅 日历 📆 计划 ⏰ 闹钟 ⏱️ 秒表 ⏲️ 定时器 ⌚ 手表","状态指示图标#状态指示图标":"成功/完成\n✅ ✓ ✔ ✓ ✔ 🎉 🏆 🥇 🏅 ✅ 任务完成 ✓ 成功 ✔ 验证通过 错误/失败\n❌ ✗ ✘ ⚠️ 🚫 🚨 💥 🔥 🆘 ❌ 错误 ✗ 失败 ⚠️ 警告 🚨 告警 进行中\n🔄 ⏳ ⌛ 🕐 🕑 🕒 🕓 🕔 🕕 🕖 🕗 🕘 🕙 🕚 🕛 🔄 处理中 ⏳ 等待 ⌛ 加载中","监控专用图标#监控专用图标":"监控状态\n👁️ 监控 🔍 检查 📡 探测 🎯 目标 📍 位置 📌 标记 🏷️ 标签 告警级别\n🔔 通知 📢 广播 🚨 紧急告警 ⚠️ 警告 ℹ️ 信息 ❓ 疑问 ❗ 重要","符号与标记#符号与标记":"箭头\n⬆️ 上箭头 ⬇️ 下箭头 ⬅️ 左箭头 ➡️ 右箭头 ↕️ 上下箭头 ↔️ 左右箭头 ↖️ 左上 ↗️ 右上 ↘️ 右下 ↙️ 左下 ⏫ 快速上 ⏬ 快速下 🔽 向下三角形 🔼 向上三角形 数学符号\n➕ 加 ➖ 减 ✖️ 乘 ➗ 除 ♾️ 无限 💯 百分 🔢 数字","系统资源图标#系统资源图标":"硬件资源\n💻 电脑/CPU 💾 内存/存储 💿 磁盘/CD 📀 DVD 🔋 电池 🖥️ 显示器 ⌨️ 键盘 🖱️ 鼠标 📡 网络 📶 信号 服务器相关\n🖥️ 服务器 🗄️ 数据库 🔌 连接 📊 图表 📈 增长 📉 下降 📋 日志 🗂️ 文件夹","网络与连接#网络与连接":"网络状态\n🌐 全球网络 📡 卫星 📶 信号强度 📲 移动设备 ☎️ 电话 📞 通话 📠 传真 连接状态\n🔗 链接 🔌 插头 📎 附件 🖇️ 回形针 🔐 加密 🔓 解锁 🔒 锁定","颜色状态图标#颜色状态图标":"彩色圆圈\n🔴 🟠 🟡 🟢 🔵 🟣 ⚫ ⚪ 🟤 🔴 紧急 🟠 高危 🟡 警告 🟢 正常 🔵 信息 其他形状\n🔺 🔻 ⬜ ⬛ ◼️ ◻️ ◾ ◽ ▪️ ▫️ 🔺 上升 🔻 下降"},"title":"图标"},"/docs/linux/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/":{"data":{"":"","golang#golang":"下载\nwget https://dl.google.com/go/go1.22.0.linux-amd64.tar.gz 配置\ntar xf go1.22.0.linux-amd64.tar.gz -C /usr/local/ cat \u003e\u003e /etc/profile \u003c","jdk#jdk":"下载\nwget https://mirrors.tuna.tsinghua.edu.cn/Adoptium/17/jdk/x64/linux/OpenJDK17U-jdk_x64_linux_hotspot_17.0.18_8.tar.gz 配置\ntar xf OpenJDK17U-jdk_x64_linux_hotspot_17.0.18_8.tar.gz -C /usr/local/ cat \u003e\u003e /etc/profile \u003c","nodejs#node.js":"下载\nwget https://mirrors.aliyun.com/nodejs-release/v23.0.0/node-v23.0.0-linux-x64.tar.gz 配置\ntar xf node-v23.0.0-linux-x64.tar.gz -C /usr/local/ cat \u003e\u003e /etc/profile \u003c","python3#python3":"下载\nwget https://mirrors.tuna.tsinghua.edu.cn/python/3.10.5/Python-3.10.5.tgz 配置\n# 升级yum并安装编译依赖 yum update -y yum install -y gcc gcc-c++ make zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel wget tar -zxvf Python-3.10.5.tgz cd Python-3.10.5 # 1. 配置编译参数（指定安装路径为/usr/local/python310，方便管理） ./configure --prefix=/usr/local/python310 --enable-optimizations --with-ssl # 参数说明： # --prefix：指定安装目录，避免和系统Python冲突 # --enable-optimizations：开启编译优化，提升Python运行效率 # --with-ssl：解决后续pip安装包时的SSL报错问题 # 2. 编译（-j后接CPU核心数，比如4核就写-j4，加速编译） make -j $(nproc) # 3. 安装（不会覆盖系统Python） make install echo \"export PATH=/usr/local/python310/bin:\\$PATH\" \u003e\u003e /etc/profile source /etc/profile 验证\npython3 -V","简介#简介":"配置golang, node.js, python, jdk等环境, 以下下载链接可以选择对应版本号下载"},"title":"开发环境"},"/docs/linux/%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%95%B0/":{"data":{"":"","修改文件打开数#修改文件打开数":"临时修改（重启失效）\n# 修改当前会话的限制 ulimit -n 65536 # 修改系统级限制（立即生效） echo 1048576 \u003e /proc/sys/fs/file-max 永久修改\n修改系统配置文件 # 添加或修改以下参数 fs.file-max = 1048576 fs.nr_open = 1048576 # 使配置立即生效 sudo sysctl -p 修改用户限制（针对特定用户或所有用户） # 在文件末尾添加（针对所有用户） * soft nofile 65536 * hard nofile 131072 # 或针对特定用户 username soft nofile 65536 username hard nofile 131072 对于systemd服务（重要！CentOS 7/Rocky 9大部分服务使用systemd） # 方法A：修改全局配置 sudo vi /etc/systemd/system.conf # 取消注释并修改： DefaultLimitNOFILE=65536 DefaultLimitNPROC=65536 # 方法B：针对特定服务 sudo vi /usr/lib/systemd/system/.service # 在[Service]部分添加： LimitNOFILE=65536 LimitNPROC=65536 # 重新加载systemd配置 sudo systemctl daemon-reload sudo systemctl restart","查看当前文件打开数限制#查看当前文件打开数限制":"查看系统级限制\n# 查看当前系统限制 cat /proc/sys/fs/file-max cat /proc/sys/fs/file-nr 查看用户级限制\n# 查看当前用户限制 ulimit -n # 查看软限制 ulimit -Hn # 查看硬限制 # 查看特定进程的限制 cat /proc//limits | grep \"Max open files\" 查看已使用的文件数\n# 查看系统已使用的文件描述符数量 cat /proc/sys/fs/file-nr # 输出三个数字：已分配文件句柄数 | 已使用文件句柄数 | 文件句柄最大值 # 查看所有进程打开的文件数 lsof | wc -l # 查看特定进程打开的文件数 lsof -p | wc -l","验证修改结果#验证修改结果":"# 1. 验证系统级限制 cat /proc/sys/fs/file-max # 2. 验证用户级限制（重新登录后生效） ulimit -n ulimit -Hn # 3. 验证特定进程的限制 cat /proc/self/limits | grep \"Max open files\" # 4. 验证服务进程的限制 sudo systemctl show | grep LimitNOFILE"},"title":"文件打开数"},"/docs/linux/%E6%97%B6%E5%8C%BA/":{"data":{"":"","alpine-系统#Alpine 系统":"Alpine 基于 BusyBox，默认使用 busybox-timezone 工具管理时区，操作步骤如下：\n查看当前时区\n# 方法1：通过日期命令查看（包含时区信息） date # 示例输出：Wed Oct 18 10:30:00 UTC 2023（UTC 表示当前为世界标准时间，未修改时区） # 方法2：查看时区配置文件 cat /etc/timezone # 若文件存在，直接显示时区；若不存在，默认为 UTC 修改为东八区\n# 步骤1：安装时区依赖包（若未安装） apk add -U tzdata # 步骤2：设置时区为 Asia/Shanghai ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 步骤3：写入时区信息到 /etc/timezone（可选，部分应用依赖该文件） echo \"Asia/Shanghai\" \u003e /etc/timezone 验证修改结果\ndate # 正确输出示例：Wed Oct 18 18:30:00 CST 2023（CST 即中国标准时间，东八区）","centos-7-系统#CentOS 7 系统":"CentOS 7 支持 timedatectl（系统自带），也可通过手动修改时区文件实现：\n查看当前时区\n# 方法1：使用 timedatectl timedatectl # 示例输出：Time zone: UTC (UTC, +0000) # 方法2：查看 /etc/localtime 软链接指向 ls -l /etc/localtime # 示例输出：lrwxrwxrwx 1 root root 25 Oct 18 10:00 /etc/localtime -\u003e /usr/share/zoneinfo/UTC 修改为东八区\n# 方法1：使用 timedatectl（推荐） sudo timedatectl set-timezone Asia/Shanghai # 方法2：手动替换时区软链接（兼容无 timedatectl 场景） sudo rm -rf /etc/localtime # 删除原有软链接 sudo ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 验证修改结果\ntimedatectl # 正确输出示例：Time zone: Asia/Shanghai (CST, +0800) date # 正确输出示例：Wed Oct 18 18:40:00 CST 2023","rocky-linux-9-系统#Rocky Linux 9 系统":"Rocky Linux 9 基于 RHEL 9，默认自带 timedatectl，操作与 CentOS 7 类似但更简洁：\n查看当前时区\ntimedatectl # 示例输出：Time zone: UTC (UTC, +0000) 修改为东八区\nsudo timedatectl set-timezone Asia/Shanghai 验证修改结果\ntimedatectl # 正确输出示例：Time zone: Asia/Shanghai (CST, +0800) date # 正确输出示例：Wed Oct 18 18:45:00 CST 2023","ubuntu--debian-系统#Ubuntu \u0026amp; Debian 系统":"Ubuntu（16.04+）和 Debian（9+）均支持 timedatectl 工具（系统自带），操作步骤完全一致：\n查看当前时区\n# 方法1：使用 timedatectl（推荐，直观显示时区） timedatectl # 示例输出：Time zone: UTC (UTC, +0000)（当前时区为 UTC） # 方法2：通过日期命令查看 date # 示例输出：Wed Oct 18 10:35:00 UTC 2023 修改为东八区\n# 方法1：使用 timedatectl 直接设置（推荐，无需手动创建链接） sudo timedatectl set-timezone Asia/Shanghai # 方法2：手动创建时区软链接（兼容旧版本系统） sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime sudo dpkg-reconfigure -f noninteractive tzdata # 刷新时区配置（可选） 验证修改结果\ntimedatectl # 正确输出示例：Time zone: Asia/Shanghai (CST, +0800) date # 正确输出示例：Wed Oct 18 18:35:00 CST 2023","常见问题与注意事项#常见问题与注意事项":"权限不足报错：操作时若提示 “Permission denied”，在命令前添加 sudo（需当前用户有 sudo 权限），或切换至 root 用户（su - root）。\n时区文件不存在：若提示 /usr/share/zoneinfo/Asia/Shanghai 不存在，需安装时区数据包：\nAlpine：apk add tzdata\nUbuntu/Debian：sudo apt install tzdata\nCentOS 7/Rocky 9：sudo yum install tzdata\n修改后时间不同步：可通过 NTP 同步时间（以 chrony 为例）： # 安装 chrony（部分系统默认已安装） sudo yum install chrony -y # CentOS 7/Rocky 9 sudo apt install chrony -y # Ubuntu/Debian sudo apk add chrony -y # Alpine # 启动并设置开机自启 sudo systemctl start chronyd sudo systemctl enable chronyd # 手动同步时间 sudo chronyc sources -v"},"title":"时区"},"/docs/linux/%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%A4%A7%E5%85%A8/":{"data":{"":"","alpine#alpine":"sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories apk update","centos7#centos7":"curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo yum clean all yum makecache","debian#debian":"debian 9-11 归档源 cat \u003e /etc/apt/sources.list \u003c","golang#golang":"临时配置 # 直接写入 Go 环境配置（跨终端生效） go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct # 查看所有 Go 环境变量，确认 GOPROXY 已修改 go env 永久配置 ~/.bashrcexport GOPROXY=https://mirrors.aliyun.com/goproxy/,direct","linux流量代理#linux流量代理":"10.0.0.82: 代理服务器\n# HTTP/HTTPS 代理 export http_proxy=\"http://10.0.0.82:7890\" export https_proxy=\"http://10.0.0.82:7890\" # SOCKS 代理 export socks_proxy=\"socks5://10.0.0.82:7890\" export SOCKS_PROXY=\"socks5://10.0.0.82:7890\"","npm#npm":"临时生效 npm install [包名] --registry=https://registry.npmmirror.com 永久配置 # 设置 npm 全局镜像源为淘宝源（核心命令） npm config set registry https://registry.npmmirror.com # 验证是否设置成功 npm config get registry","python#Python":"临时配置 pip install [包名] -i https://mirrors.aliyun.com/pypi/simple/ 永久配置 # 设置阿里云源为全局默认（推荐） pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ # 验证是否配置成功 pip config get global.index-url","rocky9#rocky9":"sed -e 's|^mirrorlist=|#mirrorlist=|g' \\ -e 's|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g' \\ -i.bak \\ /etc/yum.repos.d/[Rr]ocky*.repo makecache","ubuntu#ubuntu":"sed -i 's/archive.ubuntu.com/mirrors.aliyun.com/g' /etc/apt/sources.list sed -i 's/security.ubuntu.com/mirrors.aliyun.com/g' /etc/apt/sources.list apt update"},"title":"镜像仓库大全"},"/docs/linux/ansible/":{"data":{"":"","ansible示例#ansible示例":"执行shell命令, 默认shell模块\nansible webservers -a \"ls\" 拷贝文件\nansible webservers -m copy -a \"src=/root/nginx.conf dest=/etc/nginx/nginx.conf mode=644\" 修改文件\n# 修改文件内容111为123 ansible webservers -m lineinfile -a \"path=/root/hxq.txt regexp='^111' line='123'\" # 添加配置到文件末尾, 防止重复 ansible webservers -m lineinfile -a \"path=/root/hxq.txt line='222' regexp='^222$' state=present\" # 添加配置到文件开头, 防止重复 ansible webservers -m lineinfile -a \"path=/root/hxq.txt line='555' regexp='^555$' insertafter=BOF state=present\" 服务操作\n# 批量安装nginx ansible webservers -m yum -a \"name=nginx state=present\" # 批量卸载nginx ansible webservers -m yum -a \"name=nginx state=absent\" # 批量升级nginx ansible webservers -m yum -a \"name=nginx state=latest\" # 批量启动nginx服务，并设置开机自启 ansible webservers -m service -a \"name=nginx state=started enabled=yes\" # 批量停止nginx服务 ansible webservers -m service -a \"name=nginx state=stopped\" # 批量重启nginx服务 ansible webservers -m service -a \"name=nginx state=restarted\" # 批量重新加载nginx配置（无需重启服务） ansible webservers -m service -a \"name=nginx state=reloaded\"","主机配置#主机配置":"Ansible通过「主机清单」识别被控主机，默认路径为 /etc/ansible/hosts，也可自定义清单文件Inventory（推荐，避免修改系统默认文件）。\n编辑默认主机清单（简单场景）\n/etc/ansible/hosts# 格式1：单主机（IP） 192.168.1.100 # 格式2：单主机（IP+端口+用户名，默认端口22可省略） 192.168.1.101:22 ansible_user=root ansible_ssh_pass=123456 # 格式3：主机组（批量管理，推荐） [webservers] # 主机组名称（自定义，如web服务器组） 192.168.1.102 ansible_user=root ansible_ssh_pass=123456 192.168.1.103 ansible_user=root ansible_ssh_pass=123456 [dbservers] # 另一组（数据库服务器组） 192.168.1.104 ansible_user=root ansible_ssh_pass=123456 # 格式4: 主机组嵌套 [myhost:children] webservers dbservers # 格式4: 参数复用 [myhost:vars] ansible_ssh_user=root ansible_ssh_pass=123456 ansible_ssh_port=22 ansible_ssh_common_args='-o ProxyCommand=\"ssh -W %h:%p -q root@111.111.111.111\"' # 跳板机 自定义主机清单（推荐，实操首选）\n自定义清单文件（如 inventory.ini），避免修改系统默认配置，后续命令通过 -i 指定该文件即可。\n在当前目录创建自定义清单\ninventory.ini# 2. 写入内容（支持密钥认证，更安全） [web] web1 ansible_host=192.168.1.102 ansible_user=root ansible_ssh_private_key_file=/root/.ssh/id_rsa web2 ansible_host=192.168.1.103 ansible_user=root ansible_ssh_private_key_file=/root/.ssh/id_rsa [db] db1 ansible_host=192.168.1.104 ansible_user=root ansible_ssh_private_key_file=/root/.ssh/id_rsa 验证主机连通性（核心命令） 使用 ansible ping 模块，测试控制节点与被控主机的连通性，这是Ansible实操的第一步。\n# 场景1：测试默认清单（/etc/ansible/hosts）中所有主机 ansible all -m ping # 场景2：测试默认清单中webservers主机组 ansible webservers -m ping # 场景3：测试自定义清单（inventory.ini）中web组 ansible web -i inventory.ini -m ping # 场景4：测试自定义清单中单个主机（web1） ansible web1 -i inventory.ini -m ping # 场景5：密码认证，临时指定密码（避免明文写在清单） ansible web -i inventory.ini -m ping -k # 执行后会提示输入被控主机密码（ansible_ssh_pass） 成功提示：被控主机返回 “pong”: “pong”，表示连通正常；失败请检查SSH服务、网络、密码/密钥是否正确。","安装#安装":"# 1. 安装EPEL源（CentOS默认无Ansible仓库） yum install -y epel-release # 2. 安装Ansible yum install -y ansible # 3. 验证安装（查看版本） ansible --version # 正常输出示例：ansible [core 2.14.2]","简介#简介":"本文档以「命令行实操」为核心，搭配高频场景Playbook示例，帮助运维/开发人员快速掌握Ansible的基础使用、主机管理、模块调用及Playbook编写，可直接复制命令和示例进行实操，降低入门成本。 Ansible是一款开源的自动化运维工具，基于SSH协议（无需在被控主机安装客户端），可实现批量主机管理、配置部署、任务执行、服务启停等自动化操作，核心优势：轻量、无客户端、配置简单、可扩展性强。"},"title":"Ansible"},"/docs/window/":{"data":{"简介#简介":"简介记录一些window的技术内容。"},"title":"Window"},"/docs/window/server2022/":{"data":{"":"","优化脚本#优化脚本":"@echo off chcp 65001 \u003enul title Windows Server 2022 自动化配置脚本 - 管理员模式 cls echo ======================================================== echo ✅ Windows Server 2022 一站式系统配置脚本 echo ✅ 含：关更新/关UAC/永不关屏/开远程桌面等 echo ======================================================== echo. echo ★ 脚本将自动执行所有配置，全程无需手动操作... pause \u003enul :: ====== 【1/10】彻底关闭Windows系统自动更新 ====== echo. echo [1/10] 正在关闭Windows系统自动更新... :: Server 2022 专属注册表路径，兼容LTSC版本 reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\" /v AUOptions /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU\" /v NoAutoUpdate /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\" /v DisableWindowsUpdateAccess /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 :: 禁用并停止Windows Update相关服务（Server 2022 关键服务） sc config wuauserv start= disabled \u003enul 2\u003e\u00261 sc stop wuauserv \u003enul 2\u003e\u00261 sc config cryptSvc start= disabled \u003enul 2\u003e\u00261 sc stop cryptSvc \u003enul 2\u003e\u00261 sc config bits start= disabled \u003enul 2\u003e\u00261 sc stop bits \u003enul 2\u003e\u00261 sc config trustedinstaller start= disabled \u003enul 2\u003e\u00261 echo ✔ 系统自动更新已禁用（Server 2022 专属配置） :: ====== 【2/10】UAC用户账户控制 → 设置为从不通知 ====== echo. echo [2/10] 正在设置UAC为从不通知... reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\" /v EnableLUA /t REG_DWORD /d 0 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\" /v ConsentPromptBehaviorAdmin /t REG_DWORD /d 0 /f \u003enul 2\u003e\u00261 echo ✔ UAC已设置为【从不通知】（重启后生效） :: ====== 【3/10】关闭系统休眠功能（释放磁盘空间） ====== echo. echo [3/10] 正在关闭系统休眠... powercfg -h off \u003enul 2\u003e\u00261 :: Server 2022 额外清理休眠文件残留 del /f /q C:\\hiberfil.sys \u003enul 2\u003e\u00261 echo ✔ 休眠功能已关闭，已释放休眠文件占用空间 :: ====== 【4/10】永久关闭屏幕保护程序（适配Server桌面版，Core版无影响） ====== echo. echo [4/10] 正在关闭屏幕保护程序... reg add \"HKCU\\Control Panel\\Desktop\" /v ScreenSaveActive /t REG_SZ /d 0 /f \u003enul 2\u003e\u00261 reg add \"HKCU\\Control Panel\\Desktop\" /v ScreenSaverIsSecure /t REG_SZ /d 0 /f \u003enul 2\u003e\u00261 :: 额外配置系统级屏保禁用，适配Server多用户 reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v ScreenSaverExecutable /t REG_SZ /d \"\" /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v ScreenSaverActive /t REG_SZ /d 0 /f \u003enul 2\u003e\u00261 echo ✔ 屏幕保护已永久关闭（桌面版生效，Core版无影响） :: ====== 【5/10】关闭Windows Defender实时防护（Server 2022 专属配置） ====== echo. echo [5/10] 正在关闭Defender实时防护... reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows Defender\" /v DisableAntiSpyware /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\" /v DisableRealtimeMonitoring /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\" /v DisableWindowsDefender /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 :: 禁用并停止Server 2022 Defender相关服务 sc config WinDefend start= disabled \u003enul 2\u003e\u00261 sc stop WinDefend \u003enul 2\u003e\u00261 sc config WdNisSvc start= disabled \u003enul 2\u003e\u00261 sc stop WdNisSvc \u003enul 2\u003e\u00261 echo ✔ Defender实时防护已禁用（避免误杀EXE服务） :: ====== 【6/10】关闭通知中心所有弹窗（Server 2022 适配） ====== echo. echo [6/10] 正在关闭所有系统/应用通知... reg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Notifications\\Settings\" /v NOC_GLOBAL_SETTING_ALLOW_NOTIFICATIONS /t REG_DWORD /d 0 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PushNotifications\" /v ToastEnabled /t REG_DWORD /d 0 /f \u003enul 2\u003e\u00261 :: Server 2022 额外禁用服务器管理器通知 reg add \"HKCU\\Software\\Microsoft\\ServerManager\" /v DoNotOpenServerManagerAtLogon /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SOFTWARE\\Microsoft\\ServerManager\" /v DoNotOpenServerManagerAtLogon /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 echo ✔ 通知中心已关闭，所有弹窗将被屏蔽（含服务器管理器通知） :: ====== 【7/10】关闭系统自动维护（Server 2022 关键优化） ====== echo. echo [7/10] 正在关闭系统自动维护... reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\Maintenance\" /v MaintenanceDisabled /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 :: 禁用维护相关任务计划，避免后台干扰EXE服务 schtasks /change /tn \"\\Microsoft\\Windows\\TaskScheduler\\Maintenance Configurator\" /disable \u003enul 2\u003e\u00261 schtasks /change /tn \"\\Microsoft\\Windows\\TaskScheduler\\Regular Maintenance\" /disable \u003enul 2\u003e\u00261 echo ✔ 自动维护已关闭，禁止后台自动扫描/优化（避免服务中断） :: ====== 【8/10】关闭快速启动（Server 2022 电源配置） ====== echo. echo [8/10] 正在关闭快速启动... powercfg /setactive scheme_current \u003enul 2\u003e\u00261 reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Power\" /v HiberbootEnabled /t REG_DWORD /d 0 /f \u003enul 2\u003e\u00261 :: Server 2022 额外禁用混合关机 powercfg /setdcvalueindex scheme_current sub_boot hybridboot 0 \u003enul 2\u003e\u00261 powercfg /setacvalueindex scheme_current sub_boot hybridboot 0 \u003enul 2\u003e\u00261 echo ✔ 快速启动已关闭，提升开机兼容性（适配服务器长期运行） :: ====== 【9/10】开启远程桌面连接（Server 2022 专属，含防火墙放行） ====== echo. echo [9/10] 正在开启远程桌面并放行防火墙... :: 启用远程桌面核心配置 reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v UserAuthentication /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v AllowTSConnections /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 :: Server 2022 防火墙放行（支持远程桌面默认端口3389） netsh advfirewall firewall set rule group=\"远程桌面\" new enable=yes \u003enul 2\u003e\u00261 netsh advfirewall firewall add rule name=\"RDP-TCP-3389\" dir=in action=allow protocol=TCP localport=3389 enable=yes profile=any \u003enul 2\u003e\u00261 :: 启用远程桌面服务（Server 2022 关键服务） sc config TermService start= auto \u003enul 2\u003e\u00261 sc start TermService \u003enul 2\u003e\u00261 echo ✔ 远程桌面已开启，防火墙已放行（3389端口，可直接连接） :: ====== 【10/10】设置系统永不关闭屏幕、永不睡眠（Server 2022 电源优化） ====== echo. echo [10/10] 正在设置永不关闭屏幕、永不系统睡眠... :: 交流电源（服务器通常接市电，优先配置） powercfg /change monitor-timeout-ac 0 \u003enul 2\u003e\u00261 powercfg /change standby-timeout-ac 0 \u003enul 2\u003e\u00261 powercfg /change hibernate-timeout-ac 0 \u003enul 2\u003e\u00261 powercfg /change disk-timeout-ac 0 \u003enul 2\u003e\u00261 :: 直流电源（备用，适配便携小主机） powercfg /change monitor-timeout-dc 0 \u003enul 2\u003e\u00261 powercfg /change standby-timeout-dc 0 \u003enul 2\u003e\u00261 powercfg /change hibernate-timeout-dc 0 \u003enul 2\u003e\u00261 powercfg /change disk-timeout-dc 0 \u003enul 2\u003e\u00261 :: Server 2022 额外设置高性能电源计划，避免降频干扰服务 powercfg /setactive 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c \u003enul 2\u003e\u00261 echo ✔ 已设置：显示器永不关闭、系统永不睡眠、高性能电源模式 :: ====== 执行完成 ====== echo. echo ======================================================== echo ✅ 所有10项配置全部执行完成！✅ echo ⚠ 提示：UAC、远程桌面、系统更新需重启服务器后生效 echo ⚠ 其余功能已立即生效，重启后所有配置全部稳定运行 echo ⚠ 注意：该脚本适配Server 2022 LTSC（Core版/桌面版均支持） echo ======================================================== pause","开机启动#开机启动":":: 1. 静默安装系统服务（服务名称自定义，如 BasketballService，格式：nssm install 服务名 \"EXE完整路径\"） nssm install BasketballService \"D:\\ServerApps\\baskball.exe\" :: 2. 配置服务：设置为开机自动启动 nssm set BasketballService Start SERVICE_AUTO_START :: 3. 配置服务：意外崩溃后自动重启（延迟3秒，避免频繁重启） nssm set BasketballService AppRestartDelay 3000 nssm set BasketballService OnExit Default RESTART :: 4. 配置服务：运行目录（即baskball.exe所在文件夹，避免程序读取依赖文件失败） nssm set BasketballService AppDirectory \"D:\\ServerApps\" :: 5. （可选）配置日志输出，方便排查程序运行报错（自动创建日志目录） nssm set BasketballService AppStdout \"D:\\ServerApps\\Logs\\stdout.log\" nssm set BasketballService AppStderr \"D:\\ServerApps\\Logs\\stderr.log\" nssm set BasketballService AppRotateFiles 1 :: 启用日志文件轮转 nssm set BasketballService AppRotateBytes 10485760 :: 单个日志文件最大10MB :: 6. 启动该服务（立即验证是否能正常运行，无需重启） nssm start BasketballService :: 重启baskball.exe对应的服务 nssm restart BasketballService :: 停止baskball.exe对应的服务 nssm stop BasketballService :: 卸载服务（如需重新配置，confirm表示无需手动确认） nssm remove BasketballService confirm","激活#激活":"slmgr /ipk WX4NM-KYWYW-QJJR4-XV3QB-6VM33 slmgr /skms kms.03k.org slmgr /ato","自动登录#自动登录":":: 1. 启用自动登录（1=启用，0=禁用） reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v AutoAdminLogon /t REG_DWORD /d 1 /f :: 2. 设置默认登录用户名（替换为你的实际账号，如 Administrator、自定义账号） reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v DefaultUserName /t REG_SZ /d \"你的登录账号\" /f :: 3. 设置默认登录密码（替换为你的账号对应密码，明文存储，仅限内网服务器） reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v DefaultPassword /t REG_SZ /d \"你的账号密码\" /f :: 4. （可选）跳过「Ctrl+Alt+Del」登录提示，直接进入桌面 reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v AutoLogonSkipHotKey /t REG_DWORD /d 1 /f"},"title":"Server2022"},"/docs/window/win11/":{"data":{"":"","优化脚本#优化脚本":"@echo off chcp 65001 \u003enul title Win11系统自动化配置脚本 - 管理员模式 cls echo ======================================================== echo ✅ Win11 一站式系统配置脚本（完整版） echo ✅ 含：关更新/关UAC/永不关屏/开远程桌面等 echo ======================================================== echo. echo ★ 脚本将自动执行所有配置，全程无需手动操作... pause \u003enul :: ====== 【1/11】彻底关闭Windows系统自动更新 ====== echo. echo [1/11] 正在关闭Windows系统自动更新... reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\" /v AUOptions /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU\" /v NoAutoUpdate /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 sc config wuauserv start= disabled \u003enul 2\u003e\u00261 sc stop wuauserv \u003enul 2\u003e\u00261 sc config wuauserv type= own \u003enul 2\u003e\u00261 echo ✔ 系统自动更新已禁用 :: ====== 【2/11】UAC用户账户控制 → 设置为从不通知 ====== echo. echo [2/11] 正在设置UAC为从不通知... reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\" /v EnableLUA /t REG_DWORD /d 0 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\" /v ConsentPromptBehaviorAdmin /t REG_DWORD /d 0 /f \u003enul 2\u003e\u00261 echo ✔ UAC已设置为【从不通知】 :: ====== 【3/11】关闭系统休眠功能（释放磁盘空间） ====== echo. echo [3/11] 正在关闭系统休眠... powercfg -h off \u003enul 2\u003e\u00261 echo ✔ 休眠功能已关闭，已释放休眠文件占用空间 :: ====== 【4/11】永久关闭屏幕保护程序 ====== echo. echo [4/11] 正在关闭屏幕保护程序... reg add \"HKCU\\Control Panel\\Desktop\" /v ScreenSaveActive /t REG_SZ /d 0 /f \u003enul 2\u003e\u00261 reg add \"HKCU\\Control Panel\\Desktop\" /v ScreenSaverIsSecure /t REG_SZ /d 0 /f \u003enul 2\u003e\u00261 echo ✔ 屏幕保护已永久关闭 :: ====== 【5/11】关闭Windows Defender实时防护 ====== echo. echo [5/11] 正在关闭Defender实时防护... reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows Defender\" /v DisableAntiSpyware /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\" /v DisableRealtimeMonitoring /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 sc config WinDefend start= disabled \u003enul 2\u003e\u00261 sc stop WinDefend \u003enul 2\u003e\u00261 echo ✔ Defender实时防护已禁用 :: ====== 【6/11】关闭通知中心所有弹窗 ====== echo. echo [6/11] 正在关闭所有系统/应用通知... reg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Notifications\\Settings\" /v NOC_GLOBAL_SETTING_ALLOW_NOTIFICATIONS /t REG_DWORD /d 0 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PushNotifications\" /v ToastEnabled /t REG_DWORD /d 0 /f \u003enul 2\u003e\u00261 echo ✔ 通知中心已关闭，所有弹窗将被屏蔽 :: ====== 【7/11】关闭系统自动维护 ====== echo. echo [7/11] 正在关闭系统自动维护... reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\Maintenance\" /v MaintenanceDisabled /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 echo ✔ 自动维护已关闭，禁止后台自动扫描/优化 :: ====== 【8/11】关闭快速启动 ====== echo. echo [8/11] 正在关闭快速启动... powercfg /setactive scheme_current \u003enul 2\u003e\u00261 reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Power\" /v HiberbootEnabled /t REG_DWORD /d 0 /f \u003enul 2\u003e\u00261 echo ✔ 快速启动已关闭，提升开机兼容性 :: ====== 【9/11】关闭Windows搜索服务 ====== echo. echo [9/11] 正在关闭Windows搜索服务... sc config WSearch start= disabled \u003enul 2\u003e\u00261 sc stop WSearch \u003enul 2\u003e\u00261 echo ✔ Windows搜索服务已禁用 :: ====== 【10/11】开启远程桌面连接（含防火墙放行） ====== echo. echo [10/11] 正在开启远程桌面并放行防火墙... reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f \u003enul 2\u003e\u00261 reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v UserAuthentication /t REG_DWORD /d 1 /f \u003enul 2\u003e\u00261 netsh advfirewall firewall set rule group=\"远程桌面\" new enable=yes \u003enul 2\u003e\u00261 echo ✔ 远程桌面已开启，防火墙已放行 :: ====== 【11/11】设置系统永不关闭屏幕、永不睡眠 ====== echo. echo [11/11] 正在设置永不关闭屏幕、永不系统睡眠... powercfg /change monitor-timeout-ac 0 \u003enul 2\u003e\u00261 powercfg /change monitor-timeout-dc 0 \u003enul 2\u003e\u00261 powercfg /change standby-timeout-ac 0 \u003enul 2\u003e\u00261 powercfg /change standby-timeout-dc 0 \u003enul 2\u003e\u00261 powercfg /change hibernate-timeout-ac 0 \u003enul 2\u003e\u00261 powercfg /change hibernate-timeout-dc 0 \u003enul 2\u003e\u00261 echo ✔ 已设置：显示器永不关闭、系统永不睡眠 :: ====== 执行完成 ====== echo. echo ======================================================== echo ✅ 所有11项配置全部执行完成！✅ echo ⚠ 提示：UAC、远程桌面、系统更新需重启电脑后生效 echo ⚠ 其余功能已立即生效，重启后所有配置全部生效 echo ======================================================== pause","安装跳过window账号使用本地账号断网安装#安装跳过window账号，使用本地账号（断网安装）":"安装到网络连接界面时，按 shfit+f10 ，输入以下命令：\n# win11 版本执行 start ms-cxh:localonly # 以上无法成功,可尝试以下命令 oobe\\bypassnro","开机启动#开机启动":"开机启动配置\n# 设置开机启动 reg add \"HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v PyEXE_AutoRun /t REG_SZ /d \"cmd /c timeout /t 3 /nobreak \u003enul \u0026\u0026 start \"\"\"\" \"\"C:\\Users\\test.exe\"\"\" /f # 查看开机启动 reg query \"HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v PyEXE_AutoRun #删除开机启动 reg delete \"HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v PyEXE_AutoRun /f PyEXE_AutoRun: 启动规则名称 C:\\Users\\test.exe: 启动程序路径 自动登录\n# 1. 开启自动登录功能 reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v AutoAdminLogon /t REG_DWORD /d 1 /f # 2. 写入你的登录账户名（替换为自己的用户名，例：User01） reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v DefaultUserName /t REG_SZ /d \"User01\" /f # 3. 写入你的登录密码（替换为自己的密码，例：123456Abc） reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v DefaultPassword /t REG_SZ /d \"123456Abc\" /f # 恢复密码登入 reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v AutoAdminLogon /t REG_DWORD /d 0 /f 执行脚本, 断开远程登录, 显示桌面\n@echo off chcp 65001 \u003e nul 2\u003e\u00261 title 维持远程桌面会话（断开后不锁屏） echo ============================================== echo 正在查询当前活跃用户会话... echo ============================================== :: 自动查询当前Active（活跃）会话的ID，排除无关信息 for /f \"tokens=2,3 delims= \" %%a in ('quser ^| findstr /i \"Active\"') do ( set \"session_id=%%a\" :: 处理会话ID可能为字母+数字的情况（部分系统环境） if not \"%%b\"==\"\" ( set \"session_id=%%b\" ) ) :: 判断是否查询到会话ID if not defined session_id ( echo 错误：未查询到活跃的用户会话，请确认已建立远程连接！ :: 延迟2秒后退出（让用户看到错误提示，可按需调整或删除） timeout /t 2 /nobreak \u003e nul exit /b 1 ) echo 查询到活跃会话ID：%session_id% echo 正在执行tscon命令，维持会话不锁屏... echo ============================================== :: 执行tscon命令，重定向会话到控制台（需管理员权限） tscon %session_id% /dest:console /v :: 命令执行结果判断 if %errorlevel% equ 0 ( echo 操作成功！会话已维持，断开远程桌面后将显示桌面而非锁屏。 ) else ( echo 错误：命令执行失败，请以管理员身份运行此脚本！ ) echo ============================================== :: 移除原有的pause命令，无需用户手动干预，脚本执行完毕直接退出 :: 可选：添加短暂延迟，让用户看清执行结果（如需立即退出，删除下面这行即可） timeout /t 1 /nobreak \u003e nul","激活#激活":"打开cmd，输入以下内容\nslmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX slmgr /skms kms.03k.org 或 slmgr /skms kms.loli.best slmgr /ato 打开powershell，输入以下内容\nirm https://get.activated.win | iex 或 irm massgrave.dev/get.ps1 | iex 专业版可选密钥：\nD9W3G-NR2D7-6W3RK-WDD4J-7FR9G Y7DJH-BN6WF-BB3RV-82F8F-R3KTY Y4N7X-CF46G-92G6X-PW86V-VT9TT RWQ2G-NXBQJ-JRT27-WX36H-JQKTT H7HNM-BWTTC-4M99X-KM3Y3-B98XG RHNCY-6QJWF-WPHP7-2FP87-4C2KG 2X7P3-NGJTH-Q9TJF-8XDP9-T83GT J2WWN-Q4338-3GFW9-BWQVK-MG9TT NBQWQ-W9PTV-B4YWP-4K773-T6PKG"},"title":"win11"},"/showcase/":{"data":{"":"开发常用工具集合网站 it-tools 热点新闻集合网站 news AI集合网站 AI 一个代理工具 creamdata 中国科学技术大学测速网站 wan 查询ip归属网站 ipshu 毫秒镜像加速 docker U盘启动工具 ventoy 系统网站 msdn ssh客户端工具 tabby"},"title":"工具展示"}}